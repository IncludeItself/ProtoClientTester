// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data_proto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_data_5fproto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_data_5fproto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "error_code/common.pb.h"
#include "error_code/network.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_data_5fproto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_data_5fproto_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_data_5fproto_2eproto;
namespace data {
class BatchRequest;
struct BatchRequestDefaultTypeInternal;
extern BatchRequestDefaultTypeInternal _BatchRequest_default_instance_;
class CompileSourceCodeRequest;
struct CompileSourceCodeRequestDefaultTypeInternal;
extern CompileSourceCodeRequestDefaultTypeInternal _CompileSourceCodeRequest_default_instance_;
class CompileSourceCodeResponse;
struct CompileSourceCodeResponseDefaultTypeInternal;
extern CompileSourceCodeResponseDefaultTypeInternal _CompileSourceCodeResponse_default_instance_;
class ErrorResponse;
struct ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class ExecuteIRCodeRequest;
struct ExecuteIRCodeRequestDefaultTypeInternal;
extern ExecuteIRCodeRequestDefaultTypeInternal _ExecuteIRCodeRequest_default_instance_;
class ExecuteIRCodeRequest_ParametersEntry_DoNotUse;
struct ExecuteIRCodeRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ExecuteIRCodeRequest_ParametersEntry_DoNotUseDefaultTypeInternal _ExecuteIRCodeRequest_ParametersEntry_DoNotUse_default_instance_;
class ExecuteIRCodeResponse;
struct ExecuteIRCodeResponseDefaultTypeInternal;
extern ExecuteIRCodeResponseDefaultTypeInternal _ExecuteIRCodeResponse_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class MessageFrame;
struct MessageFrameDefaultTypeInternal;
extern MessageFrameDefaultTypeInternal _MessageFrame_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class RequestHeader;
struct RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
struct ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class SaveSourceCodeRequest;
struct SaveSourceCodeRequestDefaultTypeInternal;
extern SaveSourceCodeRequestDefaultTypeInternal _SaveSourceCodeRequest_default_instance_;
class SaveSourceCodeRequest_MetadataEntry_DoNotUse;
struct SaveSourceCodeRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern SaveSourceCodeRequest_MetadataEntry_DoNotUseDefaultTypeInternal _SaveSourceCodeRequest_MetadataEntry_DoNotUse_default_instance_;
class SaveSourceCodeResponse;
struct SaveSourceCodeResponseDefaultTypeInternal;
extern SaveSourceCodeResponseDefaultTypeInternal _SaveSourceCodeResponse_default_instance_;
}  // namespace data
PROTOBUF_NAMESPACE_OPEN
template<> ::data::BatchRequest* Arena::CreateMaybeMessage<::data::BatchRequest>(Arena*);
template<> ::data::CompileSourceCodeRequest* Arena::CreateMaybeMessage<::data::CompileSourceCodeRequest>(Arena*);
template<> ::data::CompileSourceCodeResponse* Arena::CreateMaybeMessage<::data::CompileSourceCodeResponse>(Arena*);
template<> ::data::ErrorResponse* Arena::CreateMaybeMessage<::data::ErrorResponse>(Arena*);
template<> ::data::ExecuteIRCodeRequest* Arena::CreateMaybeMessage<::data::ExecuteIRCodeRequest>(Arena*);
template<> ::data::ExecuteIRCodeRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::data::ExecuteIRCodeRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::data::ExecuteIRCodeResponse* Arena::CreateMaybeMessage<::data::ExecuteIRCodeResponse>(Arena*);
template<> ::data::Heartbeat* Arena::CreateMaybeMessage<::data::Heartbeat>(Arena*);
template<> ::data::LoginRequest* Arena::CreateMaybeMessage<::data::LoginRequest>(Arena*);
template<> ::data::LoginResponse* Arena::CreateMaybeMessage<::data::LoginResponse>(Arena*);
template<> ::data::MessageFrame* Arena::CreateMaybeMessage<::data::MessageFrame>(Arena*);
template<> ::data::Notification* Arena::CreateMaybeMessage<::data::Notification>(Arena*);
template<> ::data::RequestHeader* Arena::CreateMaybeMessage<::data::RequestHeader>(Arena*);
template<> ::data::ResponseHeader* Arena::CreateMaybeMessage<::data::ResponseHeader>(Arena*);
template<> ::data::SaveSourceCodeRequest* Arena::CreateMaybeMessage<::data::SaveSourceCodeRequest>(Arena*);
template<> ::data::SaveSourceCodeRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::data::SaveSourceCodeRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::data::SaveSourceCodeResponse* Arena::CreateMaybeMessage<::data::SaveSourceCodeResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace data {

enum Notification_NotifyType : int {
  Notification_NotifyType_SYSTEM_ANNOUNCEMENT = 0,
  Notification_NotifyType_ORDER_STATUS_CHANGE = 1,
  Notification_NotifyType_FRIEND_REQUEST = 2,
  Notification_NotifyType_Notification_NotifyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Notification_NotifyType_Notification_NotifyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Notification_NotifyType_IsValid(int value);
constexpr Notification_NotifyType Notification_NotifyType_NotifyType_MIN = Notification_NotifyType_SYSTEM_ANNOUNCEMENT;
constexpr Notification_NotifyType Notification_NotifyType_NotifyType_MAX = Notification_NotifyType_FRIEND_REQUEST;
constexpr int Notification_NotifyType_NotifyType_ARRAYSIZE = Notification_NotifyType_NotifyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Notification_NotifyType_descriptor();
template<typename T>
inline const std::string& Notification_NotifyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Notification_NotifyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Notification_NotifyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Notification_NotifyType_descriptor(), enum_t_value);
}
inline bool Notification_NotifyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Notification_NotifyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Notification_NotifyType>(
    Notification_NotifyType_descriptor(), name, value);
}
enum ExecuteIRCodeRequest_ExecutionMode : int {
  ExecuteIRCodeRequest_ExecutionMode_JIT = 0,
  ExecuteIRCodeRequest_ExecutionMode_INTERPRET = 1,
  ExecuteIRCodeRequest_ExecutionMode_BOTH = 2,
  ExecuteIRCodeRequest_ExecutionMode_ExecuteIRCodeRequest_ExecutionMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExecuteIRCodeRequest_ExecutionMode_ExecuteIRCodeRequest_ExecutionMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExecuteIRCodeRequest_ExecutionMode_IsValid(int value);
constexpr ExecuteIRCodeRequest_ExecutionMode ExecuteIRCodeRequest_ExecutionMode_ExecutionMode_MIN = ExecuteIRCodeRequest_ExecutionMode_JIT;
constexpr ExecuteIRCodeRequest_ExecutionMode ExecuteIRCodeRequest_ExecutionMode_ExecutionMode_MAX = ExecuteIRCodeRequest_ExecutionMode_BOTH;
constexpr int ExecuteIRCodeRequest_ExecutionMode_ExecutionMode_ARRAYSIZE = ExecuteIRCodeRequest_ExecutionMode_ExecutionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecuteIRCodeRequest_ExecutionMode_descriptor();
template<typename T>
inline const std::string& ExecuteIRCodeRequest_ExecutionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecuteIRCodeRequest_ExecutionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecuteIRCodeRequest_ExecutionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecuteIRCodeRequest_ExecutionMode_descriptor(), enum_t_value);
}
inline bool ExecuteIRCodeRequest_ExecutionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecuteIRCodeRequest_ExecutionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecuteIRCodeRequest_ExecutionMode>(
    ExecuteIRCodeRequest_ExecutionMode_descriptor(), name, value);
}
enum RequestType : int {
  UNKNOWN = 0,
  LOGIN_REQUEST = 1,
  LOGIN_RESPONSE = 2,
  HEARTBEAT = 3,
  ERROR_RESPONSE = 4,
  NOTIFICATION = 5,
  BATCH_REQUEST = 6,
  SAVE_SOURCE_CODE_REQUEST = 7,
  SAVE_SOURCE_CODE_RESPONSE = 8,
  COMPILE_SOURCE_REQUEST = 9,
  COMPILE_SOURCE_RESPONSE = 10,
  EXECUTE_IR_REQUEST = 11,
  EXECUTE_IR_RESPONSE = 12,
  RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestType_IsValid(int value);
constexpr RequestType RequestType_MIN = UNKNOWN;
constexpr RequestType RequestType_MAX = EXECUTE_IR_RESPONSE;
constexpr int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestType_descriptor();
template<typename T>
inline const std::string& RequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestType_descriptor(), enum_t_value);
}
inline bool RequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
enum StatusCode : int {
  SUCCESS = 0,
  BAD_REQUEST = 1,
  UNAUTHORIZED = 2,
  FORBIDDEN = 3,
  NOT_FOUND = 4,
  INTERNAL_ERROR = 5,
  SERVICE_UNAVAILABLE = 6,
  TIMEOUT = 7,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatusCode_IsValid(int value);
constexpr StatusCode StatusCode_MIN = SUCCESS;
constexpr StatusCode StatusCode_MAX = TIMEOUT;
constexpr int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusCode_descriptor();
template<typename T>
inline const std::string& StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusCode_descriptor(), enum_t_value);
}
inline bool StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
// ===================================================================

class RequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.RequestHeader) */ {
 public:
  inline RequestHeader() : RequestHeader(nullptr) {}
  ~RequestHeader() override;
  explicit PROTOBUF_CONSTEXPR RequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestHeader& from) {
    RequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.RequestHeader";
  }
  protected:
  explicit RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kAuthTokenFieldNumber = 5,
    kTimestampFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string client_id = 2;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // string auth_token = 5;
  void clear_auth_token();
  const std::string& auth_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_token();
  PROTOBUF_NODISCARD std::string* release_auth_token();
  void set_allocated_auth_token(std::string* auth_token);
  private:
  const std::string& _internal_auth_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_token(const std::string& value);
  std::string* _internal_mutable_auth_token();
  public:

  // int64 timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .data.RequestType type = 4;
  void clear_type();
  ::data::RequestType type() const;
  void set_type(::data::RequestType value);
  private:
  ::data::RequestType _internal_type() const;
  void _internal_set_type(::data::RequestType value);
  public:

  // @@protoc_insertion_point(class_scope:data.RequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_token_;
    int64_t timestamp_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.ResponseHeader) */ {
 public:
  inline ResponseHeader() : ResponseHeader(nullptr) {}
  ~ResponseHeader() override;
  explicit PROTOBUF_CONSTEXPR ResponseHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseHeader& from) {
    ResponseHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.ResponseHeader";
  }
  protected:
  explicit ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kErrorMessageFieldNumber = 4,
    kTimestampFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .data.StatusCode status = 3;
  void clear_status();
  ::data::StatusCode status() const;
  void set_status(::data::StatusCode value);
  private:
  ::data::StatusCode _internal_status() const;
  void _internal_set_status(::data::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:data.ResponseHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t timestamp_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class MessageFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.MessageFrame) */ {
 public:
  inline MessageFrame() : MessageFrame(nullptr) {}
  ~MessageFrame() override;
  explicit PROTOBUF_CONSTEXPR MessageFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageFrame(const MessageFrame& from);
  MessageFrame(MessageFrame&& from) noexcept
    : MessageFrame() {
    *this = ::std::move(from);
  }

  inline MessageFrame& operator=(const MessageFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageFrame& operator=(MessageFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageFrame& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kLoginRequest = 2,
    kLoginResponse = 3,
    kHeartbeat = 4,
    kErrorResponse = 5,
    kNotification = 6,
    kBatch = 7,
    kSaveSourceRequest = 8,
    kSaveSourceResponse = 9,
    kCompileRequest = 10,
    kCompileResponse = 11,
    kExecuteIrRequest = 12,
    kExecuteIrResponse = 13,
    BODY_NOT_SET = 0,
  };

  static inline const MessageFrame* internal_default_instance() {
    return reinterpret_cast<const MessageFrame*>(
               &_MessageFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MessageFrame& a, MessageFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageFrame& from) {
    MessageFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.MessageFrame";
  }
  protected:
  explicit MessageFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLoginRequestFieldNumber = 2,
    kLoginResponseFieldNumber = 3,
    kHeartbeatFieldNumber = 4,
    kErrorResponseFieldNumber = 5,
    kNotificationFieldNumber = 6,
    kBatchFieldNumber = 7,
    kSaveSourceRequestFieldNumber = 8,
    kSaveSourceResponseFieldNumber = 9,
    kCompileRequestFieldNumber = 10,
    kCompileResponseFieldNumber = 11,
    kExecuteIrRequestFieldNumber = 12,
    kExecuteIrResponseFieldNumber = 13,
  };
  // .data.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::data::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::data::RequestHeader* release_header();
  ::data::RequestHeader* mutable_header();
  void set_allocated_header(::data::RequestHeader* header);
  private:
  const ::data::RequestHeader& _internal_header() const;
  ::data::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::data::RequestHeader* header);
  ::data::RequestHeader* unsafe_arena_release_header();

  // .data.LoginRequest login_request = 2;
  bool has_login_request() const;
  private:
  bool _internal_has_login_request() const;
  public:
  void clear_login_request();
  const ::data::LoginRequest& login_request() const;
  PROTOBUF_NODISCARD ::data::LoginRequest* release_login_request();
  ::data::LoginRequest* mutable_login_request();
  void set_allocated_login_request(::data::LoginRequest* login_request);
  private:
  const ::data::LoginRequest& _internal_login_request() const;
  ::data::LoginRequest* _internal_mutable_login_request();
  public:
  void unsafe_arena_set_allocated_login_request(
      ::data::LoginRequest* login_request);
  ::data::LoginRequest* unsafe_arena_release_login_request();

  // .data.LoginResponse login_response = 3;
  bool has_login_response() const;
  private:
  bool _internal_has_login_response() const;
  public:
  void clear_login_response();
  const ::data::LoginResponse& login_response() const;
  PROTOBUF_NODISCARD ::data::LoginResponse* release_login_response();
  ::data::LoginResponse* mutable_login_response();
  void set_allocated_login_response(::data::LoginResponse* login_response);
  private:
  const ::data::LoginResponse& _internal_login_response() const;
  ::data::LoginResponse* _internal_mutable_login_response();
  public:
  void unsafe_arena_set_allocated_login_response(
      ::data::LoginResponse* login_response);
  ::data::LoginResponse* unsafe_arena_release_login_response();

  // .data.Heartbeat heartbeat = 4;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::data::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::data::Heartbeat* release_heartbeat();
  ::data::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::data::Heartbeat* heartbeat);
  private:
  const ::data::Heartbeat& _internal_heartbeat() const;
  ::data::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::data::Heartbeat* heartbeat);
  ::data::Heartbeat* unsafe_arena_release_heartbeat();

  // .data.ErrorResponse error_response = 5;
  bool has_error_response() const;
  private:
  bool _internal_has_error_response() const;
  public:
  void clear_error_response();
  const ::data::ErrorResponse& error_response() const;
  PROTOBUF_NODISCARD ::data::ErrorResponse* release_error_response();
  ::data::ErrorResponse* mutable_error_response();
  void set_allocated_error_response(::data::ErrorResponse* error_response);
  private:
  const ::data::ErrorResponse& _internal_error_response() const;
  ::data::ErrorResponse* _internal_mutable_error_response();
  public:
  void unsafe_arena_set_allocated_error_response(
      ::data::ErrorResponse* error_response);
  ::data::ErrorResponse* unsafe_arena_release_error_response();

  // .data.Notification notification = 6;
  bool has_notification() const;
  private:
  bool _internal_has_notification() const;
  public:
  void clear_notification();
  const ::data::Notification& notification() const;
  PROTOBUF_NODISCARD ::data::Notification* release_notification();
  ::data::Notification* mutable_notification();
  void set_allocated_notification(::data::Notification* notification);
  private:
  const ::data::Notification& _internal_notification() const;
  ::data::Notification* _internal_mutable_notification();
  public:
  void unsafe_arena_set_allocated_notification(
      ::data::Notification* notification);
  ::data::Notification* unsafe_arena_release_notification();

  // .data.BatchRequest batch = 7;
  bool has_batch() const;
  private:
  bool _internal_has_batch() const;
  public:
  void clear_batch();
  const ::data::BatchRequest& batch() const;
  PROTOBUF_NODISCARD ::data::BatchRequest* release_batch();
  ::data::BatchRequest* mutable_batch();
  void set_allocated_batch(::data::BatchRequest* batch);
  private:
  const ::data::BatchRequest& _internal_batch() const;
  ::data::BatchRequest* _internal_mutable_batch();
  public:
  void unsafe_arena_set_allocated_batch(
      ::data::BatchRequest* batch);
  ::data::BatchRequest* unsafe_arena_release_batch();

  // .data.SaveSourceCodeRequest save_source_request = 8;
  bool has_save_source_request() const;
  private:
  bool _internal_has_save_source_request() const;
  public:
  void clear_save_source_request();
  const ::data::SaveSourceCodeRequest& save_source_request() const;
  PROTOBUF_NODISCARD ::data::SaveSourceCodeRequest* release_save_source_request();
  ::data::SaveSourceCodeRequest* mutable_save_source_request();
  void set_allocated_save_source_request(::data::SaveSourceCodeRequest* save_source_request);
  private:
  const ::data::SaveSourceCodeRequest& _internal_save_source_request() const;
  ::data::SaveSourceCodeRequest* _internal_mutable_save_source_request();
  public:
  void unsafe_arena_set_allocated_save_source_request(
      ::data::SaveSourceCodeRequest* save_source_request);
  ::data::SaveSourceCodeRequest* unsafe_arena_release_save_source_request();

  // .data.SaveSourceCodeResponse save_source_response = 9;
  bool has_save_source_response() const;
  private:
  bool _internal_has_save_source_response() const;
  public:
  void clear_save_source_response();
  const ::data::SaveSourceCodeResponse& save_source_response() const;
  PROTOBUF_NODISCARD ::data::SaveSourceCodeResponse* release_save_source_response();
  ::data::SaveSourceCodeResponse* mutable_save_source_response();
  void set_allocated_save_source_response(::data::SaveSourceCodeResponse* save_source_response);
  private:
  const ::data::SaveSourceCodeResponse& _internal_save_source_response() const;
  ::data::SaveSourceCodeResponse* _internal_mutable_save_source_response();
  public:
  void unsafe_arena_set_allocated_save_source_response(
      ::data::SaveSourceCodeResponse* save_source_response);
  ::data::SaveSourceCodeResponse* unsafe_arena_release_save_source_response();

  // .data.CompileSourceCodeRequest compile_request = 10;
  bool has_compile_request() const;
  private:
  bool _internal_has_compile_request() const;
  public:
  void clear_compile_request();
  const ::data::CompileSourceCodeRequest& compile_request() const;
  PROTOBUF_NODISCARD ::data::CompileSourceCodeRequest* release_compile_request();
  ::data::CompileSourceCodeRequest* mutable_compile_request();
  void set_allocated_compile_request(::data::CompileSourceCodeRequest* compile_request);
  private:
  const ::data::CompileSourceCodeRequest& _internal_compile_request() const;
  ::data::CompileSourceCodeRequest* _internal_mutable_compile_request();
  public:
  void unsafe_arena_set_allocated_compile_request(
      ::data::CompileSourceCodeRequest* compile_request);
  ::data::CompileSourceCodeRequest* unsafe_arena_release_compile_request();

  // .data.CompileSourceCodeResponse compile_response = 11;
  bool has_compile_response() const;
  private:
  bool _internal_has_compile_response() const;
  public:
  void clear_compile_response();
  const ::data::CompileSourceCodeResponse& compile_response() const;
  PROTOBUF_NODISCARD ::data::CompileSourceCodeResponse* release_compile_response();
  ::data::CompileSourceCodeResponse* mutable_compile_response();
  void set_allocated_compile_response(::data::CompileSourceCodeResponse* compile_response);
  private:
  const ::data::CompileSourceCodeResponse& _internal_compile_response() const;
  ::data::CompileSourceCodeResponse* _internal_mutable_compile_response();
  public:
  void unsafe_arena_set_allocated_compile_response(
      ::data::CompileSourceCodeResponse* compile_response);
  ::data::CompileSourceCodeResponse* unsafe_arena_release_compile_response();

  // .data.ExecuteIRCodeRequest execute_ir_request = 12;
  bool has_execute_ir_request() const;
  private:
  bool _internal_has_execute_ir_request() const;
  public:
  void clear_execute_ir_request();
  const ::data::ExecuteIRCodeRequest& execute_ir_request() const;
  PROTOBUF_NODISCARD ::data::ExecuteIRCodeRequest* release_execute_ir_request();
  ::data::ExecuteIRCodeRequest* mutable_execute_ir_request();
  void set_allocated_execute_ir_request(::data::ExecuteIRCodeRequest* execute_ir_request);
  private:
  const ::data::ExecuteIRCodeRequest& _internal_execute_ir_request() const;
  ::data::ExecuteIRCodeRequest* _internal_mutable_execute_ir_request();
  public:
  void unsafe_arena_set_allocated_execute_ir_request(
      ::data::ExecuteIRCodeRequest* execute_ir_request);
  ::data::ExecuteIRCodeRequest* unsafe_arena_release_execute_ir_request();

  // .data.ExecuteIRCodeResponse execute_ir_response = 13;
  bool has_execute_ir_response() const;
  private:
  bool _internal_has_execute_ir_response() const;
  public:
  void clear_execute_ir_response();
  const ::data::ExecuteIRCodeResponse& execute_ir_response() const;
  PROTOBUF_NODISCARD ::data::ExecuteIRCodeResponse* release_execute_ir_response();
  ::data::ExecuteIRCodeResponse* mutable_execute_ir_response();
  void set_allocated_execute_ir_response(::data::ExecuteIRCodeResponse* execute_ir_response);
  private:
  const ::data::ExecuteIRCodeResponse& _internal_execute_ir_response() const;
  ::data::ExecuteIRCodeResponse* _internal_mutable_execute_ir_response();
  public:
  void unsafe_arena_set_allocated_execute_ir_response(
      ::data::ExecuteIRCodeResponse* execute_ir_response);
  ::data::ExecuteIRCodeResponse* unsafe_arena_release_execute_ir_response();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:data.MessageFrame)
 private:
  class _Internal;
  void set_has_login_request();
  void set_has_login_response();
  void set_has_heartbeat();
  void set_has_error_response();
  void set_has_notification();
  void set_has_batch();
  void set_has_save_source_request();
  void set_has_save_source_response();
  void set_has_compile_request();
  void set_has_compile_response();
  void set_has_execute_ir_request();
  void set_has_execute_ir_response();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::data::RequestHeader* header_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::data::LoginRequest* login_request_;
      ::data::LoginResponse* login_response_;
      ::data::Heartbeat* heartbeat_;
      ::data::ErrorResponse* error_response_;
      ::data::Notification* notification_;
      ::data::BatchRequest* batch_;
      ::data::SaveSourceCodeRequest* save_source_request_;
      ::data::SaveSourceCodeResponse* save_source_response_;
      ::data::CompileSourceCodeRequest* compile_request_;
      ::data::CompileSourceCodeResponse* compile_response_;
      ::data::ExecuteIRCodeRequest* execute_ir_request_;
      ::data::ExecuteIRCodeResponse* execute_ir_response_;
    } body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordHashFieldNumber = 2,
    kDeviceInfoFieldNumber = 3,
    kAppVersionFieldNumber = 4,
    kTokenFieldNumber = 5,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password_hash = 2;
  void clear_password_hash();
  const std::string& password_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password_hash();
  PROTOBUF_NODISCARD std::string* release_password_hash();
  void set_allocated_password_hash(std::string* password_hash);
  private:
  const std::string& _internal_password_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password_hash(const std::string& value);
  std::string* _internal_mutable_password_hash();
  public:

  // string device_info = 3;
  void clear_device_info();
  const std::string& device_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_info();
  PROTOBUF_NODISCARD std::string* release_device_info();
  void set_allocated_device_info(std::string* device_info);
  private:
  const std::string& _internal_device_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_info(const std::string& value);
  std::string* _internal_mutable_device_info();
  public:

  // string app_version = 4;
  void clear_app_version();
  const std::string& app_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_version();
  PROTOBUF_NODISCARD std::string* release_app_version();
  void set_allocated_app_version(std::string* app_version);
  private:
  const std::string& _internal_app_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_version(const std::string& value);
  std::string* _internal_mutable_app_version();
  public:

  // string token = 5;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:data.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kUserNicknameFieldNumber = 4,
    kExpireTimeFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kUserRoleFieldNumber = 5,
  };
  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string user_nickname = 4;
  void clear_user_nickname();
  const std::string& user_nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_nickname();
  PROTOBUF_NODISCARD std::string* release_user_nickname();
  void set_allocated_user_nickname(std::string* user_nickname);
  private:
  const std::string& _internal_user_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_nickname(const std::string& value);
  std::string* _internal_mutable_user_nickname();
  public:

  // uint64 expire_time = 3;
  void clear_expire_time();
  uint64_t expire_time() const;
  void set_expire_time(uint64_t value);
  private:
  uint64_t _internal_expire_time() const;
  void _internal_set_expire_time(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 user_role = 5;
  void clear_user_role();
  uint32_t user_role() const;
  void set_user_role(uint32_t value);
  private:
  uint32_t _internal_user_role() const;
  void _internal_set_user_role(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_nickname_;
    uint64_t expire_time_;
    bool success_;
    uint32_t user_role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() override;
  explicit PROTOBUF_CONSTEXPR Heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Heartbeat& from) {
    Heartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionStatusFieldNumber = 3,
    kLastActiveTimeFieldNumber = 1,
    kServerTimeFieldNumber = 2,
  };
  // string connection_status = 3;
  void clear_connection_status();
  const std::string& connection_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection_status();
  PROTOBUF_NODISCARD std::string* release_connection_status();
  void set_allocated_connection_status(std::string* connection_status);
  private:
  const std::string& _internal_connection_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_status(const std::string& value);
  std::string* _internal_mutable_connection_status();
  public:

  // uint64 last_active_time = 1;
  void clear_last_active_time();
  uint64_t last_active_time() const;
  void set_last_active_time(uint64_t value);
  private:
  uint64_t _internal_last_active_time() const;
  void _internal_set_last_active_time(uint64_t value);
  public:

  // uint64 server_time = 2;
  void clear_server_time();
  uint64_t server_time() const;
  void set_server_time(uint64_t value);
  private:
  uint64_t _internal_server_time() const;
  void _internal_set_server_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_status_;
    uint64_t last_active_time_;
    uint64_t server_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ErrorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.ErrorResponse) */ {
 public:
  inline ErrorResponse() : ErrorResponse(nullptr) {}
  ~ErrorResponse() override;
  explicit PROTOBUF_CONSTEXPR ErrorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorResponse(const ErrorResponse& from);
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ErrorCodeCase {
    kCommonCode = 1,
    kNetworkCode = 2,
    ERRORCODE_NOT_SET = 0,
  };

  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorResponse& from) {
    ErrorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.ErrorResponse";
  }
  protected:
  explicit ErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 3,
    kSolutionFieldNumber = 4,
    kRequestTypeFieldNumber = 5,
    kMessageFieldNumber = 13,
    kCommonCodeFieldNumber = 1,
    kNetworkCodeFieldNumber = 2,
  };
  // string detail = 3;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // string solution = 4;
  void clear_solution();
  const std::string& solution() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_solution(ArgT0&& arg0, ArgT... args);
  std::string* mutable_solution();
  PROTOBUF_NODISCARD std::string* release_solution();
  void set_allocated_solution(std::string* solution);
  private:
  const std::string& _internal_solution() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_solution(const std::string& value);
  std::string* _internal_mutable_solution();
  public:

  // string request_type = 5;
  void clear_request_type();
  const std::string& request_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_type();
  PROTOBUF_NODISCARD std::string* release_request_type();
  void set_allocated_request_type(std::string* request_type);
  private:
  const std::string& _internal_request_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_type(const std::string& value);
  std::string* _internal_mutable_request_type();
  public:

  // string message = 13;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .common.ErrorCode common_code = 1;
  bool has_common_code() const;
  private:
  bool _internal_has_common_code() const;
  public:
  void clear_common_code();
  ::common::ErrorCode common_code() const;
  void set_common_code(::common::ErrorCode value);
  private:
  ::common::ErrorCode _internal_common_code() const;
  void _internal_set_common_code(::common::ErrorCode value);
  public:

  // .network.ErrorCode network_code = 2;
  bool has_network_code() const;
  private:
  bool _internal_has_network_code() const;
  public:
  void clear_network_code();
  ::network::ErrorCode network_code() const;
  void set_network_code(::network::ErrorCode value);
  private:
  ::network::ErrorCode _internal_network_code() const;
  void _internal_set_network_code(::network::ErrorCode value);
  public:

  void clear_ErrorCode();
  ErrorCodeCase ErrorCode_case() const;
  // @@protoc_insertion_point(class_scope:data.ErrorResponse)
 private:
  class _Internal;
  void set_has_common_code();
  void set_has_network_code();

  inline bool has_ErrorCode() const;
  inline void clear_has_ErrorCode();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr solution_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    union ErrorCodeUnion {
      constexpr ErrorCodeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int common_code_;
      int network_code_;
    } ErrorCode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Notification& from) {
    Notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Notification_NotifyType NotifyType;
  static constexpr NotifyType SYSTEM_ANNOUNCEMENT =
    Notification_NotifyType_SYSTEM_ANNOUNCEMENT;
  static constexpr NotifyType ORDER_STATUS_CHANGE =
    Notification_NotifyType_ORDER_STATUS_CHANGE;
  static constexpr NotifyType FRIEND_REQUEST =
    Notification_NotifyType_FRIEND_REQUEST;
  static inline bool NotifyType_IsValid(int value) {
    return Notification_NotifyType_IsValid(value);
  }
  static constexpr NotifyType NotifyType_MIN =
    Notification_NotifyType_NotifyType_MIN;
  static constexpr NotifyType NotifyType_MAX =
    Notification_NotifyType_NotifyType_MAX;
  static constexpr int NotifyType_ARRAYSIZE =
    Notification_NotifyType_NotifyType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NotifyType_descriptor() {
    return Notification_NotifyType_descriptor();
  }
  template<typename T>
  static inline const std::string& NotifyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NotifyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NotifyType_Name.");
    return Notification_NotifyType_Name(enum_t_value);
  }
  static inline bool NotifyType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NotifyType* value) {
    return Notification_NotifyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kTypeFieldNumber = 1,
    kNeedAckFieldNumber = 4,
    kCreateTimeFieldNumber = 3,
  };
  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .data.Notification.NotifyType type = 1;
  void clear_type();
  ::data::Notification_NotifyType type() const;
  void set_type(::data::Notification_NotifyType value);
  private:
  ::data::Notification_NotifyType _internal_type() const;
  void _internal_set_type(::data::Notification_NotifyType value);
  public:

  // bool need_ack = 4;
  void clear_need_ack();
  bool need_ack() const;
  void set_need_ack(bool value);
  private:
  bool _internal_need_ack() const;
  void _internal_set_need_ack(bool value);
  public:

  // uint64 create_time = 3;
  void clear_create_time();
  uint64_t create_time() const;
  void set_create_time(uint64_t value);
  private:
  uint64_t _internal_create_time() const;
  void _internal_set_create_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.Notification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int type_;
    bool need_ack_;
    uint64_t create_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class BatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.BatchRequest) */ {
 public:
  inline BatchRequest() : BatchRequest(nullptr) {}
  ~BatchRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchRequest(const BatchRequest& from);
  BatchRequest(BatchRequest&& from) noexcept
    : BatchRequest() {
    *this = ::std::move(from);
  }

  inline BatchRequest& operator=(const BatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchRequest& operator=(BatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchRequest* internal_default_instance() {
    return reinterpret_cast<const BatchRequest*>(
               &_BatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BatchRequest& a, BatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchRequest& from) {
    BatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.BatchRequest";
  }
  protected:
  explicit BatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubRequestsFieldNumber = 1,
    kNeedAtomicFieldNumber = 2,
  };
  // repeated .data.MessageFrame sub_requests = 1;
  int sub_requests_size() const;
  private:
  int _internal_sub_requests_size() const;
  public:
  void clear_sub_requests();
  ::data::MessageFrame* mutable_sub_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::MessageFrame >*
      mutable_sub_requests();
  private:
  const ::data::MessageFrame& _internal_sub_requests(int index) const;
  ::data::MessageFrame* _internal_add_sub_requests();
  public:
  const ::data::MessageFrame& sub_requests(int index) const;
  ::data::MessageFrame* add_sub_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::MessageFrame >&
      sub_requests() const;

  // bool need_atomic = 2;
  void clear_need_atomic();
  bool need_atomic() const;
  void set_need_atomic(bool value);
  private:
  bool _internal_need_atomic() const;
  void _internal_set_need_atomic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:data.BatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::MessageFrame > sub_requests_;
    bool need_atomic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class SaveSourceCodeRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SaveSourceCodeRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SaveSourceCodeRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SaveSourceCodeRequest_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SaveSourceCodeRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SaveSourceCodeRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SaveSourceCodeRequest_MetadataEntry_DoNotUse& other);
  static const SaveSourceCodeRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SaveSourceCodeRequest_MetadataEntry_DoNotUse*>(&_SaveSourceCodeRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "data.SaveSourceCodeRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "data.SaveSourceCodeRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_data_5fproto_2eproto;
};

// -------------------------------------------------------------------

class SaveSourceCodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.SaveSourceCodeRequest) */ {
 public:
  inline SaveSourceCodeRequest() : SaveSourceCodeRequest(nullptr) {}
  ~SaveSourceCodeRequest() override;
  explicit PROTOBUF_CONSTEXPR SaveSourceCodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSourceCodeRequest(const SaveSourceCodeRequest& from);
  SaveSourceCodeRequest(SaveSourceCodeRequest&& from) noexcept
    : SaveSourceCodeRequest() {
    *this = ::std::move(from);
  }

  inline SaveSourceCodeRequest& operator=(const SaveSourceCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSourceCodeRequest& operator=(SaveSourceCodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSourceCodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSourceCodeRequest* internal_default_instance() {
    return reinterpret_cast<const SaveSourceCodeRequest*>(
               &_SaveSourceCodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SaveSourceCodeRequest& a, SaveSourceCodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSourceCodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSourceCodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSourceCodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSourceCodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSourceCodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSourceCodeRequest& from) {
    SaveSourceCodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSourceCodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.SaveSourceCodeRequest";
  }
  protected:
  explicit SaveSourceCodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 6,
    kCodeIdFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kSourceCodeFieldNumber = 3,
    kCodeNameFieldNumber = 4,
    kDescriptionFieldNumber = 5,
  };
  // map<string, string> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string code_id = 1;
  void clear_code_id();
  const std::string& code_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code_id();
  PROTOBUF_NODISCARD std::string* release_code_id();
  void set_allocated_code_id(std::string* code_id);
  private:
  const std::string& _internal_code_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_id(const std::string& value);
  std::string* _internal_mutable_code_id();
  public:

  // string language = 2;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string source_code = 3;
  void clear_source_code();
  const std::string& source_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_code();
  PROTOBUF_NODISCARD std::string* release_source_code();
  void set_allocated_source_code(std::string* source_code);
  private:
  const std::string& _internal_source_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_code(const std::string& value);
  std::string* _internal_mutable_source_code();
  public:

  // string code_name = 4;
  void clear_code_name();
  const std::string& code_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code_name();
  PROTOBUF_NODISCARD std::string* release_code_name();
  void set_allocated_code_name(std::string* code_name);
  private:
  const std::string& _internal_code_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_name(const std::string& value);
  std::string* _internal_mutable_code_name();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:data.SaveSourceCodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SaveSourceCodeRequest_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class SaveSourceCodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.SaveSourceCodeResponse) */ {
 public:
  inline SaveSourceCodeResponse() : SaveSourceCodeResponse(nullptr) {}
  ~SaveSourceCodeResponse() override;
  explicit PROTOBUF_CONSTEXPR SaveSourceCodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSourceCodeResponse(const SaveSourceCodeResponse& from);
  SaveSourceCodeResponse(SaveSourceCodeResponse&& from) noexcept
    : SaveSourceCodeResponse() {
    *this = ::std::move(from);
  }

  inline SaveSourceCodeResponse& operator=(const SaveSourceCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSourceCodeResponse& operator=(SaveSourceCodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSourceCodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSourceCodeResponse* internal_default_instance() {
    return reinterpret_cast<const SaveSourceCodeResponse*>(
               &_SaveSourceCodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SaveSourceCodeResponse& a, SaveSourceCodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSourceCodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSourceCodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSourceCodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSourceCodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSourceCodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSourceCodeResponse& from) {
    SaveSourceCodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSourceCodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.SaveSourceCodeResponse";
  }
  protected:
  explicit SaveSourceCodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kSaveTimeFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string code_id = 2;
  void clear_code_id();
  const std::string& code_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code_id();
  PROTOBUF_NODISCARD std::string* release_code_id();
  void set_allocated_code_id(std::string* code_id);
  private:
  const std::string& _internal_code_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_id(const std::string& value);
  std::string* _internal_mutable_code_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 save_time = 4;
  void clear_save_time();
  uint64_t save_time() const;
  void set_save_time(uint64_t value);
  private:
  uint64_t _internal_save_time() const;
  void _internal_set_save_time(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:data.SaveSourceCodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t save_time_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class CompileSourceCodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CompileSourceCodeRequest) */ {
 public:
  inline CompileSourceCodeRequest() : CompileSourceCodeRequest(nullptr) {}
  ~CompileSourceCodeRequest() override;
  explicit PROTOBUF_CONSTEXPR CompileSourceCodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompileSourceCodeRequest(const CompileSourceCodeRequest& from);
  CompileSourceCodeRequest(CompileSourceCodeRequest&& from) noexcept
    : CompileSourceCodeRequest() {
    *this = ::std::move(from);
  }

  inline CompileSourceCodeRequest& operator=(const CompileSourceCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompileSourceCodeRequest& operator=(CompileSourceCodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompileSourceCodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompileSourceCodeRequest* internal_default_instance() {
    return reinterpret_cast<const CompileSourceCodeRequest*>(
               &_CompileSourceCodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CompileSourceCodeRequest& a, CompileSourceCodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompileSourceCodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompileSourceCodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompileSourceCodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompileSourceCodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompileSourceCodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompileSourceCodeRequest& from) {
    CompileSourceCodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileSourceCodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CompileSourceCodeRequest";
  }
  protected:
  explicit CompileSourceCodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeIdFieldNumber = 1,
    kCompilerOptionsFieldNumber = 2,
    kTargetIrVersionFieldNumber = 4,
    kOptimizeFieldNumber = 3,
  };
  // string code_id = 1;
  void clear_code_id();
  const std::string& code_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code_id();
  PROTOBUF_NODISCARD std::string* release_code_id();
  void set_allocated_code_id(std::string* code_id);
  private:
  const std::string& _internal_code_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_id(const std::string& value);
  std::string* _internal_mutable_code_id();
  public:

  // string compiler_options = 2;
  void clear_compiler_options();
  const std::string& compiler_options() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_compiler_options(ArgT0&& arg0, ArgT... args);
  std::string* mutable_compiler_options();
  PROTOBUF_NODISCARD std::string* release_compiler_options();
  void set_allocated_compiler_options(std::string* compiler_options);
  private:
  const std::string& _internal_compiler_options() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compiler_options(const std::string& value);
  std::string* _internal_mutable_compiler_options();
  public:

  // string target_ir_version = 4;
  void clear_target_ir_version();
  const std::string& target_ir_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_ir_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_ir_version();
  PROTOBUF_NODISCARD std::string* release_target_ir_version();
  void set_allocated_target_ir_version(std::string* target_ir_version);
  private:
  const std::string& _internal_target_ir_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_ir_version(const std::string& value);
  std::string* _internal_mutable_target_ir_version();
  public:

  // bool optimize = 3;
  void clear_optimize();
  bool optimize() const;
  void set_optimize(bool value);
  private:
  bool _internal_optimize() const;
  void _internal_set_optimize(bool value);
  public:

  // @@protoc_insertion_point(class_scope:data.CompileSourceCodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr compiler_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_ir_version_;
    bool optimize_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class CompileSourceCodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.CompileSourceCodeResponse) */ {
 public:
  inline CompileSourceCodeResponse() : CompileSourceCodeResponse(nullptr) {}
  ~CompileSourceCodeResponse() override;
  explicit PROTOBUF_CONSTEXPR CompileSourceCodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompileSourceCodeResponse(const CompileSourceCodeResponse& from);
  CompileSourceCodeResponse(CompileSourceCodeResponse&& from) noexcept
    : CompileSourceCodeResponse() {
    *this = ::std::move(from);
  }

  inline CompileSourceCodeResponse& operator=(const CompileSourceCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompileSourceCodeResponse& operator=(CompileSourceCodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompileSourceCodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompileSourceCodeResponse* internal_default_instance() {
    return reinterpret_cast<const CompileSourceCodeResponse*>(
               &_CompileSourceCodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CompileSourceCodeResponse& a, CompileSourceCodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompileSourceCodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompileSourceCodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompileSourceCodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompileSourceCodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompileSourceCodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompileSourceCodeResponse& from) {
    CompileSourceCodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompileSourceCodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.CompileSourceCodeResponse";
  }
  protected:
  explicit CompileSourceCodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWarningsFieldNumber = 6,
    kIrCodeIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kCompileDurationFieldNumber = 5,
    kCompileTimeFieldNumber = 4,
  };
  // repeated string warnings = 6;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // string ir_code_id = 2;
  void clear_ir_code_id();
  const std::string& ir_code_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ir_code_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ir_code_id();
  PROTOBUF_NODISCARD std::string* release_ir_code_id();
  void set_allocated_ir_code_id(std::string* ir_code_id);
  private:
  const std::string& _internal_ir_code_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ir_code_id(const std::string& value);
  std::string* _internal_mutable_ir_code_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 compile_duration = 5;
  void clear_compile_duration();
  uint32_t compile_duration() const;
  void set_compile_duration(uint32_t value);
  private:
  uint32_t _internal_compile_duration() const;
  void _internal_set_compile_duration(uint32_t value);
  public:

  // uint64 compile_time = 4;
  void clear_compile_time();
  uint64_t compile_time() const;
  void set_compile_time(uint64_t value);
  private:
  uint64_t _internal_compile_time() const;
  void _internal_set_compile_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.CompileSourceCodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ir_code_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    uint32_t compile_duration_;
    uint64_t compile_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ExecuteIRCodeRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteIRCodeRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteIRCodeRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ExecuteIRCodeRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ExecuteIRCodeRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ExecuteIRCodeRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ExecuteIRCodeRequest_ParametersEntry_DoNotUse& other);
  static const ExecuteIRCodeRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExecuteIRCodeRequest_ParametersEntry_DoNotUse*>(&_ExecuteIRCodeRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "data.ExecuteIRCodeRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "data.ExecuteIRCodeRequest.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_data_5fproto_2eproto;
};

// -------------------------------------------------------------------

class ExecuteIRCodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.ExecuteIRCodeRequest) */ {
 public:
  inline ExecuteIRCodeRequest() : ExecuteIRCodeRequest(nullptr) {}
  ~ExecuteIRCodeRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteIRCodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteIRCodeRequest(const ExecuteIRCodeRequest& from);
  ExecuteIRCodeRequest(ExecuteIRCodeRequest&& from) noexcept
    : ExecuteIRCodeRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteIRCodeRequest& operator=(const ExecuteIRCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteIRCodeRequest& operator=(ExecuteIRCodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteIRCodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteIRCodeRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteIRCodeRequest*>(
               &_ExecuteIRCodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExecuteIRCodeRequest& a, ExecuteIRCodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteIRCodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteIRCodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteIRCodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteIRCodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteIRCodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteIRCodeRequest& from) {
    ExecuteIRCodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteIRCodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.ExecuteIRCodeRequest";
  }
  protected:
  explicit ExecuteIRCodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ExecuteIRCodeRequest_ExecutionMode ExecutionMode;
  static constexpr ExecutionMode JIT =
    ExecuteIRCodeRequest_ExecutionMode_JIT;
  static constexpr ExecutionMode INTERPRET =
    ExecuteIRCodeRequest_ExecutionMode_INTERPRET;
  static constexpr ExecutionMode BOTH =
    ExecuteIRCodeRequest_ExecutionMode_BOTH;
  static inline bool ExecutionMode_IsValid(int value) {
    return ExecuteIRCodeRequest_ExecutionMode_IsValid(value);
  }
  static constexpr ExecutionMode ExecutionMode_MIN =
    ExecuteIRCodeRequest_ExecutionMode_ExecutionMode_MIN;
  static constexpr ExecutionMode ExecutionMode_MAX =
    ExecuteIRCodeRequest_ExecutionMode_ExecutionMode_MAX;
  static constexpr int ExecutionMode_ARRAYSIZE =
    ExecuteIRCodeRequest_ExecutionMode_ExecutionMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExecutionMode_descriptor() {
    return ExecuteIRCodeRequest_ExecutionMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ExecutionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExecutionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExecutionMode_Name.");
    return ExecuteIRCodeRequest_ExecutionMode_Name(enum_t_value);
  }
  static inline bool ExecutionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExecutionMode* value) {
    return ExecuteIRCodeRequest_ExecutionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kIrCodeIdFieldNumber = 1,
    kModeFieldNumber = 2,
    kTimeoutFieldNumber = 4,
  };
  // map<string, string> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string ir_code_id = 1;
  void clear_ir_code_id();
  const std::string& ir_code_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ir_code_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ir_code_id();
  PROTOBUF_NODISCARD std::string* release_ir_code_id();
  void set_allocated_ir_code_id(std::string* ir_code_id);
  private:
  const std::string& _internal_ir_code_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ir_code_id(const std::string& value);
  std::string* _internal_mutable_ir_code_id();
  public:

  // .data.ExecuteIRCodeRequest.ExecutionMode mode = 2;
  void clear_mode();
  ::data::ExecuteIRCodeRequest_ExecutionMode mode() const;
  void set_mode(::data::ExecuteIRCodeRequest_ExecutionMode value);
  private:
  ::data::ExecuteIRCodeRequest_ExecutionMode _internal_mode() const;
  void _internal_set_mode(::data::ExecuteIRCodeRequest_ExecutionMode value);
  public:

  // uint32 timeout = 4;
  void clear_timeout();
  uint32_t timeout() const;
  void set_timeout(uint32_t value);
  private:
  uint32_t _internal_timeout() const;
  void _internal_set_timeout(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.ExecuteIRCodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ExecuteIRCodeRequest_ParametersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ir_code_id_;
    int mode_;
    uint32_t timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ExecuteIRCodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:data.ExecuteIRCodeResponse) */ {
 public:
  inline ExecuteIRCodeResponse() : ExecuteIRCodeResponse(nullptr) {}
  ~ExecuteIRCodeResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteIRCodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteIRCodeResponse(const ExecuteIRCodeResponse& from);
  ExecuteIRCodeResponse(ExecuteIRCodeResponse&& from) noexcept
    : ExecuteIRCodeResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteIRCodeResponse& operator=(const ExecuteIRCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteIRCodeResponse& operator=(ExecuteIRCodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteIRCodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteIRCodeResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteIRCodeResponse*>(
               &_ExecuteIRCodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ExecuteIRCodeResponse& a, ExecuteIRCodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteIRCodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteIRCodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteIRCodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteIRCodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteIRCodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteIRCodeResponse& from) {
    ExecuteIRCodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteIRCodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "data.ExecuteIRCodeResponse";
  }
  protected:
  explicit ExecuteIRCodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionResultFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kExecutionModeUsedFieldNumber = 7,
    kSuccessFieldNumber = 1,
    kExecutionDurationFieldNumber = 6,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
  };
  // string execution_result = 2;
  void clear_execution_result();
  const std::string& execution_result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_result();
  PROTOBUF_NODISCARD std::string* release_execution_result();
  void set_allocated_execution_result(std::string* execution_result);
  private:
  const std::string& _internal_execution_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_result(const std::string& value);
  std::string* _internal_mutable_execution_result();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string execution_mode_used = 7;
  void clear_execution_mode_used();
  const std::string& execution_mode_used() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_mode_used(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_mode_used();
  PROTOBUF_NODISCARD std::string* release_execution_mode_used();
  void set_allocated_execution_mode_used(std::string* execution_mode_used);
  private:
  const std::string& _internal_execution_mode_used() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_mode_used(const std::string& value);
  std::string* _internal_mutable_execution_mode_used();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 execution_duration = 6;
  void clear_execution_duration();
  uint32_t execution_duration() const;
  void set_execution_duration(uint32_t value);
  private:
  uint32_t _internal_execution_duration() const;
  void _internal_set_execution_duration(uint32_t value);
  public:

  // uint64 start_time = 4;
  void clear_start_time();
  uint64_t start_time() const;
  void set_start_time(uint64_t value);
  private:
  uint64_t _internal_start_time() const;
  void _internal_set_start_time(uint64_t value);
  public:

  // uint64 end_time = 5;
  void clear_end_time();
  uint64_t end_time() const;
  void set_end_time(uint64_t value);
  private:
  uint64_t _internal_end_time() const;
  void _internal_set_end_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:data.ExecuteIRCodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_mode_used_;
    bool success_;
    uint32_t execution_duration_;
    uint64_t start_time_;
    uint64_t end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fproto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestHeader

// string request_id = 1;
inline void RequestHeader::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& RequestHeader::request_id() const {
  // @@protoc_insertion_point(field_get:data.RequestHeader.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.RequestHeader.request_id)
}
inline std::string* RequestHeader::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:data.RequestHeader.request_id)
  return _s;
}
inline const std::string& RequestHeader::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void RequestHeader::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_request_id() {
  // @@protoc_insertion_point(field_release:data.RequestHeader.request_id)
  return _impl_.request_id_.Release();
}
inline void RequestHeader::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.RequestHeader.request_id)
}

// string client_id = 2;
inline void RequestHeader::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& RequestHeader::client_id() const {
  // @@protoc_insertion_point(field_get:data.RequestHeader.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.RequestHeader.client_id)
}
inline std::string* RequestHeader::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:data.RequestHeader.client_id)
  return _s;
}
inline const std::string& RequestHeader::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void RequestHeader::_internal_set_client_id(const std::string& value) {
  
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_client_id() {
  
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_client_id() {
  // @@protoc_insertion_point(field_release:data.RequestHeader.client_id)
  return _impl_.client_id_.Release();
}
inline void RequestHeader::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.RequestHeader.client_id)
}

// int64 timestamp = 3;
inline void RequestHeader::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t RequestHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t RequestHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:data.RequestHeader.timestamp)
  return _internal_timestamp();
}
inline void RequestHeader::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void RequestHeader::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:data.RequestHeader.timestamp)
}

// .data.RequestType type = 4;
inline void RequestHeader::clear_type() {
  _impl_.type_ = 0;
}
inline ::data::RequestType RequestHeader::_internal_type() const {
  return static_cast< ::data::RequestType >(_impl_.type_);
}
inline ::data::RequestType RequestHeader::type() const {
  // @@protoc_insertion_point(field_get:data.RequestHeader.type)
  return _internal_type();
}
inline void RequestHeader::_internal_set_type(::data::RequestType value) {
  
  _impl_.type_ = value;
}
inline void RequestHeader::set_type(::data::RequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:data.RequestHeader.type)
}

// string auth_token = 5;
inline void RequestHeader::clear_auth_token() {
  _impl_.auth_token_.ClearToEmpty();
}
inline const std::string& RequestHeader::auth_token() const {
  // @@protoc_insertion_point(field_get:data.RequestHeader.auth_token)
  return _internal_auth_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_auth_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.RequestHeader.auth_token)
}
inline std::string* RequestHeader::mutable_auth_token() {
  std::string* _s = _internal_mutable_auth_token();
  // @@protoc_insertion_point(field_mutable:data.RequestHeader.auth_token)
  return _s;
}
inline const std::string& RequestHeader::_internal_auth_token() const {
  return _impl_.auth_token_.Get();
}
inline void RequestHeader::_internal_set_auth_token(const std::string& value) {
  
  _impl_.auth_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_auth_token() {
  
  return _impl_.auth_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_auth_token() {
  // @@protoc_insertion_point(field_release:data.RequestHeader.auth_token)
  return _impl_.auth_token_.Release();
}
inline void RequestHeader::set_allocated_auth_token(std::string* auth_token) {
  if (auth_token != nullptr) {
    
  } else {
    
  }
  _impl_.auth_token_.SetAllocated(auth_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_token_.IsDefault()) {
    _impl_.auth_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.RequestHeader.auth_token)
}

// -------------------------------------------------------------------

// ResponseHeader

// string request_id = 1;
inline void ResponseHeader::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ResponseHeader::request_id() const {
  // @@protoc_insertion_point(field_get:data.ResponseHeader.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseHeader::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ResponseHeader.request_id)
}
inline std::string* ResponseHeader::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:data.ResponseHeader.request_id)
  return _s;
}
inline const std::string& ResponseHeader::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ResponseHeader::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseHeader::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseHeader::release_request_id() {
  // @@protoc_insertion_point(field_release:data.ResponseHeader.request_id)
  return _impl_.request_id_.Release();
}
inline void ResponseHeader::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ResponseHeader.request_id)
}

// int64 timestamp = 2;
inline void ResponseHeader::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t ResponseHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t ResponseHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:data.ResponseHeader.timestamp)
  return _internal_timestamp();
}
inline void ResponseHeader::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ResponseHeader::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:data.ResponseHeader.timestamp)
}

// .data.StatusCode status = 3;
inline void ResponseHeader::clear_status() {
  _impl_.status_ = 0;
}
inline ::data::StatusCode ResponseHeader::_internal_status() const {
  return static_cast< ::data::StatusCode >(_impl_.status_);
}
inline ::data::StatusCode ResponseHeader::status() const {
  // @@protoc_insertion_point(field_get:data.ResponseHeader.status)
  return _internal_status();
}
inline void ResponseHeader::_internal_set_status(::data::StatusCode value) {
  
  _impl_.status_ = value;
}
inline void ResponseHeader::set_status(::data::StatusCode value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:data.ResponseHeader.status)
}

// string error_message = 4;
inline void ResponseHeader::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ResponseHeader::error_message() const {
  // @@protoc_insertion_point(field_get:data.ResponseHeader.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseHeader::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ResponseHeader.error_message)
}
inline std::string* ResponseHeader::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:data.ResponseHeader.error_message)
  return _s;
}
inline const std::string& ResponseHeader::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ResponseHeader::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseHeader::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseHeader::release_error_message() {
  // @@protoc_insertion_point(field_release:data.ResponseHeader.error_message)
  return _impl_.error_message_.Release();
}
inline void ResponseHeader::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ResponseHeader.error_message)
}

// -------------------------------------------------------------------

// MessageFrame

// .data.RequestHeader header = 1;
inline bool MessageFrame::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool MessageFrame::has_header() const {
  return _internal_has_header();
}
inline void MessageFrame::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::data::RequestHeader& MessageFrame::_internal_header() const {
  const ::data::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::data::RequestHeader&>(
      ::data::_RequestHeader_default_instance_);
}
inline const ::data::RequestHeader& MessageFrame::header() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.header)
  return _internal_header();
}
inline void MessageFrame::unsafe_arena_set_allocated_header(
    ::data::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.header)
}
inline ::data::RequestHeader* MessageFrame::release_header() {
  
  ::data::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::data::RequestHeader* MessageFrame::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.header)
  
  ::data::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::data::RequestHeader* MessageFrame::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::data::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::data::RequestHeader* MessageFrame::mutable_header() {
  ::data::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.header)
  return _msg;
}
inline void MessageFrame::set_allocated_header(::data::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:data.MessageFrame.header)
}

// .data.LoginRequest login_request = 2;
inline bool MessageFrame::_internal_has_login_request() const {
  return body_case() == kLoginRequest;
}
inline bool MessageFrame::has_login_request() const {
  return _internal_has_login_request();
}
inline void MessageFrame::set_has_login_request() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline void MessageFrame::clear_login_request() {
  if (_internal_has_login_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.login_request_;
    }
    clear_has_body();
  }
}
inline ::data::LoginRequest* MessageFrame::release_login_request() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.login_request)
  if (_internal_has_login_request()) {
    clear_has_body();
    ::data::LoginRequest* temp = _impl_.body_.login_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LoginRequest& MessageFrame::_internal_login_request() const {
  return _internal_has_login_request()
      ? *_impl_.body_.login_request_
      : reinterpret_cast< ::data::LoginRequest&>(::data::_LoginRequest_default_instance_);
}
inline const ::data::LoginRequest& MessageFrame::login_request() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.login_request)
  return _internal_login_request();
}
inline ::data::LoginRequest* MessageFrame::unsafe_arena_release_login_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.login_request)
  if (_internal_has_login_request()) {
    clear_has_body();
    ::data::LoginRequest* temp = _impl_.body_.login_request_;
    _impl_.body_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_login_request(::data::LoginRequest* login_request) {
  clear_body();
  if (login_request) {
    set_has_login_request();
    _impl_.body_.login_request_ = login_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.login_request)
}
inline ::data::LoginRequest* MessageFrame::_internal_mutable_login_request() {
  if (!_internal_has_login_request()) {
    clear_body();
    set_has_login_request();
    _impl_.body_.login_request_ = CreateMaybeMessage< ::data::LoginRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.login_request_;
}
inline ::data::LoginRequest* MessageFrame::mutable_login_request() {
  ::data::LoginRequest* _msg = _internal_mutable_login_request();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.login_request)
  return _msg;
}

// .data.LoginResponse login_response = 3;
inline bool MessageFrame::_internal_has_login_response() const {
  return body_case() == kLoginResponse;
}
inline bool MessageFrame::has_login_response() const {
  return _internal_has_login_response();
}
inline void MessageFrame::set_has_login_response() {
  _impl_._oneof_case_[0] = kLoginResponse;
}
inline void MessageFrame::clear_login_response() {
  if (_internal_has_login_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.login_response_;
    }
    clear_has_body();
  }
}
inline ::data::LoginResponse* MessageFrame::release_login_response() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.login_response)
  if (_internal_has_login_response()) {
    clear_has_body();
    ::data::LoginResponse* temp = _impl_.body_.login_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::LoginResponse& MessageFrame::_internal_login_response() const {
  return _internal_has_login_response()
      ? *_impl_.body_.login_response_
      : reinterpret_cast< ::data::LoginResponse&>(::data::_LoginResponse_default_instance_);
}
inline const ::data::LoginResponse& MessageFrame::login_response() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.login_response)
  return _internal_login_response();
}
inline ::data::LoginResponse* MessageFrame::unsafe_arena_release_login_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.login_response)
  if (_internal_has_login_response()) {
    clear_has_body();
    ::data::LoginResponse* temp = _impl_.body_.login_response_;
    _impl_.body_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_login_response(::data::LoginResponse* login_response) {
  clear_body();
  if (login_response) {
    set_has_login_response();
    _impl_.body_.login_response_ = login_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.login_response)
}
inline ::data::LoginResponse* MessageFrame::_internal_mutable_login_response() {
  if (!_internal_has_login_response()) {
    clear_body();
    set_has_login_response();
    _impl_.body_.login_response_ = CreateMaybeMessage< ::data::LoginResponse >(GetArenaForAllocation());
  }
  return _impl_.body_.login_response_;
}
inline ::data::LoginResponse* MessageFrame::mutable_login_response() {
  ::data::LoginResponse* _msg = _internal_mutable_login_response();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.login_response)
  return _msg;
}

// .data.Heartbeat heartbeat = 4;
inline bool MessageFrame::_internal_has_heartbeat() const {
  return body_case() == kHeartbeat;
}
inline bool MessageFrame::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void MessageFrame::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void MessageFrame::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.heartbeat_;
    }
    clear_has_body();
  }
}
inline ::data::Heartbeat* MessageFrame::release_heartbeat() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_body();
    ::data::Heartbeat* temp = _impl_.body_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::Heartbeat& MessageFrame::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *_impl_.body_.heartbeat_
      : reinterpret_cast< ::data::Heartbeat&>(::data::_Heartbeat_default_instance_);
}
inline const ::data::Heartbeat& MessageFrame::heartbeat() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.heartbeat)
  return _internal_heartbeat();
}
inline ::data::Heartbeat* MessageFrame::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_body();
    ::data::Heartbeat* temp = _impl_.body_.heartbeat_;
    _impl_.body_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_heartbeat(::data::Heartbeat* heartbeat) {
  clear_body();
  if (heartbeat) {
    set_has_heartbeat();
    _impl_.body_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.heartbeat)
}
inline ::data::Heartbeat* MessageFrame::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_body();
    set_has_heartbeat();
    _impl_.body_.heartbeat_ = CreateMaybeMessage< ::data::Heartbeat >(GetArenaForAllocation());
  }
  return _impl_.body_.heartbeat_;
}
inline ::data::Heartbeat* MessageFrame::mutable_heartbeat() {
  ::data::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.heartbeat)
  return _msg;
}

// .data.ErrorResponse error_response = 5;
inline bool MessageFrame::_internal_has_error_response() const {
  return body_case() == kErrorResponse;
}
inline bool MessageFrame::has_error_response() const {
  return _internal_has_error_response();
}
inline void MessageFrame::set_has_error_response() {
  _impl_._oneof_case_[0] = kErrorResponse;
}
inline void MessageFrame::clear_error_response() {
  if (_internal_has_error_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.error_response_;
    }
    clear_has_body();
  }
}
inline ::data::ErrorResponse* MessageFrame::release_error_response() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.error_response)
  if (_internal_has_error_response()) {
    clear_has_body();
    ::data::ErrorResponse* temp = _impl_.body_.error_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.error_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::ErrorResponse& MessageFrame::_internal_error_response() const {
  return _internal_has_error_response()
      ? *_impl_.body_.error_response_
      : reinterpret_cast< ::data::ErrorResponse&>(::data::_ErrorResponse_default_instance_);
}
inline const ::data::ErrorResponse& MessageFrame::error_response() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.error_response)
  return _internal_error_response();
}
inline ::data::ErrorResponse* MessageFrame::unsafe_arena_release_error_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.error_response)
  if (_internal_has_error_response()) {
    clear_has_body();
    ::data::ErrorResponse* temp = _impl_.body_.error_response_;
    _impl_.body_.error_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_error_response(::data::ErrorResponse* error_response) {
  clear_body();
  if (error_response) {
    set_has_error_response();
    _impl_.body_.error_response_ = error_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.error_response)
}
inline ::data::ErrorResponse* MessageFrame::_internal_mutable_error_response() {
  if (!_internal_has_error_response()) {
    clear_body();
    set_has_error_response();
    _impl_.body_.error_response_ = CreateMaybeMessage< ::data::ErrorResponse >(GetArenaForAllocation());
  }
  return _impl_.body_.error_response_;
}
inline ::data::ErrorResponse* MessageFrame::mutable_error_response() {
  ::data::ErrorResponse* _msg = _internal_mutable_error_response();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.error_response)
  return _msg;
}

// .data.Notification notification = 6;
inline bool MessageFrame::_internal_has_notification() const {
  return body_case() == kNotification;
}
inline bool MessageFrame::has_notification() const {
  return _internal_has_notification();
}
inline void MessageFrame::set_has_notification() {
  _impl_._oneof_case_[0] = kNotification;
}
inline void MessageFrame::clear_notification() {
  if (_internal_has_notification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.notification_;
    }
    clear_has_body();
  }
}
inline ::data::Notification* MessageFrame::release_notification() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.notification)
  if (_internal_has_notification()) {
    clear_has_body();
    ::data::Notification* temp = _impl_.body_.notification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::Notification& MessageFrame::_internal_notification() const {
  return _internal_has_notification()
      ? *_impl_.body_.notification_
      : reinterpret_cast< ::data::Notification&>(::data::_Notification_default_instance_);
}
inline const ::data::Notification& MessageFrame::notification() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.notification)
  return _internal_notification();
}
inline ::data::Notification* MessageFrame::unsafe_arena_release_notification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.notification)
  if (_internal_has_notification()) {
    clear_has_body();
    ::data::Notification* temp = _impl_.body_.notification_;
    _impl_.body_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_notification(::data::Notification* notification) {
  clear_body();
  if (notification) {
    set_has_notification();
    _impl_.body_.notification_ = notification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.notification)
}
inline ::data::Notification* MessageFrame::_internal_mutable_notification() {
  if (!_internal_has_notification()) {
    clear_body();
    set_has_notification();
    _impl_.body_.notification_ = CreateMaybeMessage< ::data::Notification >(GetArenaForAllocation());
  }
  return _impl_.body_.notification_;
}
inline ::data::Notification* MessageFrame::mutable_notification() {
  ::data::Notification* _msg = _internal_mutable_notification();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.notification)
  return _msg;
}

// .data.BatchRequest batch = 7;
inline bool MessageFrame::_internal_has_batch() const {
  return body_case() == kBatch;
}
inline bool MessageFrame::has_batch() const {
  return _internal_has_batch();
}
inline void MessageFrame::set_has_batch() {
  _impl_._oneof_case_[0] = kBatch;
}
inline void MessageFrame::clear_batch() {
  if (_internal_has_batch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.batch_;
    }
    clear_has_body();
  }
}
inline ::data::BatchRequest* MessageFrame::release_batch() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.batch)
  if (_internal_has_batch()) {
    clear_has_body();
    ::data::BatchRequest* temp = _impl_.body_.batch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::BatchRequest& MessageFrame::_internal_batch() const {
  return _internal_has_batch()
      ? *_impl_.body_.batch_
      : reinterpret_cast< ::data::BatchRequest&>(::data::_BatchRequest_default_instance_);
}
inline const ::data::BatchRequest& MessageFrame::batch() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.batch)
  return _internal_batch();
}
inline ::data::BatchRequest* MessageFrame::unsafe_arena_release_batch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.batch)
  if (_internal_has_batch()) {
    clear_has_body();
    ::data::BatchRequest* temp = _impl_.body_.batch_;
    _impl_.body_.batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_batch(::data::BatchRequest* batch) {
  clear_body();
  if (batch) {
    set_has_batch();
    _impl_.body_.batch_ = batch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.batch)
}
inline ::data::BatchRequest* MessageFrame::_internal_mutable_batch() {
  if (!_internal_has_batch()) {
    clear_body();
    set_has_batch();
    _impl_.body_.batch_ = CreateMaybeMessage< ::data::BatchRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.batch_;
}
inline ::data::BatchRequest* MessageFrame::mutable_batch() {
  ::data::BatchRequest* _msg = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.batch)
  return _msg;
}

// .data.SaveSourceCodeRequest save_source_request = 8;
inline bool MessageFrame::_internal_has_save_source_request() const {
  return body_case() == kSaveSourceRequest;
}
inline bool MessageFrame::has_save_source_request() const {
  return _internal_has_save_source_request();
}
inline void MessageFrame::set_has_save_source_request() {
  _impl_._oneof_case_[0] = kSaveSourceRequest;
}
inline void MessageFrame::clear_save_source_request() {
  if (_internal_has_save_source_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.save_source_request_;
    }
    clear_has_body();
  }
}
inline ::data::SaveSourceCodeRequest* MessageFrame::release_save_source_request() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.save_source_request)
  if (_internal_has_save_source_request()) {
    clear_has_body();
    ::data::SaveSourceCodeRequest* temp = _impl_.body_.save_source_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.save_source_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::SaveSourceCodeRequest& MessageFrame::_internal_save_source_request() const {
  return _internal_has_save_source_request()
      ? *_impl_.body_.save_source_request_
      : reinterpret_cast< ::data::SaveSourceCodeRequest&>(::data::_SaveSourceCodeRequest_default_instance_);
}
inline const ::data::SaveSourceCodeRequest& MessageFrame::save_source_request() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.save_source_request)
  return _internal_save_source_request();
}
inline ::data::SaveSourceCodeRequest* MessageFrame::unsafe_arena_release_save_source_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.save_source_request)
  if (_internal_has_save_source_request()) {
    clear_has_body();
    ::data::SaveSourceCodeRequest* temp = _impl_.body_.save_source_request_;
    _impl_.body_.save_source_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_save_source_request(::data::SaveSourceCodeRequest* save_source_request) {
  clear_body();
  if (save_source_request) {
    set_has_save_source_request();
    _impl_.body_.save_source_request_ = save_source_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.save_source_request)
}
inline ::data::SaveSourceCodeRequest* MessageFrame::_internal_mutable_save_source_request() {
  if (!_internal_has_save_source_request()) {
    clear_body();
    set_has_save_source_request();
    _impl_.body_.save_source_request_ = CreateMaybeMessage< ::data::SaveSourceCodeRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.save_source_request_;
}
inline ::data::SaveSourceCodeRequest* MessageFrame::mutable_save_source_request() {
  ::data::SaveSourceCodeRequest* _msg = _internal_mutable_save_source_request();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.save_source_request)
  return _msg;
}

// .data.SaveSourceCodeResponse save_source_response = 9;
inline bool MessageFrame::_internal_has_save_source_response() const {
  return body_case() == kSaveSourceResponse;
}
inline bool MessageFrame::has_save_source_response() const {
  return _internal_has_save_source_response();
}
inline void MessageFrame::set_has_save_source_response() {
  _impl_._oneof_case_[0] = kSaveSourceResponse;
}
inline void MessageFrame::clear_save_source_response() {
  if (_internal_has_save_source_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.save_source_response_;
    }
    clear_has_body();
  }
}
inline ::data::SaveSourceCodeResponse* MessageFrame::release_save_source_response() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.save_source_response)
  if (_internal_has_save_source_response()) {
    clear_has_body();
    ::data::SaveSourceCodeResponse* temp = _impl_.body_.save_source_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.save_source_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::SaveSourceCodeResponse& MessageFrame::_internal_save_source_response() const {
  return _internal_has_save_source_response()
      ? *_impl_.body_.save_source_response_
      : reinterpret_cast< ::data::SaveSourceCodeResponse&>(::data::_SaveSourceCodeResponse_default_instance_);
}
inline const ::data::SaveSourceCodeResponse& MessageFrame::save_source_response() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.save_source_response)
  return _internal_save_source_response();
}
inline ::data::SaveSourceCodeResponse* MessageFrame::unsafe_arena_release_save_source_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.save_source_response)
  if (_internal_has_save_source_response()) {
    clear_has_body();
    ::data::SaveSourceCodeResponse* temp = _impl_.body_.save_source_response_;
    _impl_.body_.save_source_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_save_source_response(::data::SaveSourceCodeResponse* save_source_response) {
  clear_body();
  if (save_source_response) {
    set_has_save_source_response();
    _impl_.body_.save_source_response_ = save_source_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.save_source_response)
}
inline ::data::SaveSourceCodeResponse* MessageFrame::_internal_mutable_save_source_response() {
  if (!_internal_has_save_source_response()) {
    clear_body();
    set_has_save_source_response();
    _impl_.body_.save_source_response_ = CreateMaybeMessage< ::data::SaveSourceCodeResponse >(GetArenaForAllocation());
  }
  return _impl_.body_.save_source_response_;
}
inline ::data::SaveSourceCodeResponse* MessageFrame::mutable_save_source_response() {
  ::data::SaveSourceCodeResponse* _msg = _internal_mutable_save_source_response();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.save_source_response)
  return _msg;
}

// .data.CompileSourceCodeRequest compile_request = 10;
inline bool MessageFrame::_internal_has_compile_request() const {
  return body_case() == kCompileRequest;
}
inline bool MessageFrame::has_compile_request() const {
  return _internal_has_compile_request();
}
inline void MessageFrame::set_has_compile_request() {
  _impl_._oneof_case_[0] = kCompileRequest;
}
inline void MessageFrame::clear_compile_request() {
  if (_internal_has_compile_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.compile_request_;
    }
    clear_has_body();
  }
}
inline ::data::CompileSourceCodeRequest* MessageFrame::release_compile_request() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.compile_request)
  if (_internal_has_compile_request()) {
    clear_has_body();
    ::data::CompileSourceCodeRequest* temp = _impl_.body_.compile_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.compile_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CompileSourceCodeRequest& MessageFrame::_internal_compile_request() const {
  return _internal_has_compile_request()
      ? *_impl_.body_.compile_request_
      : reinterpret_cast< ::data::CompileSourceCodeRequest&>(::data::_CompileSourceCodeRequest_default_instance_);
}
inline const ::data::CompileSourceCodeRequest& MessageFrame::compile_request() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.compile_request)
  return _internal_compile_request();
}
inline ::data::CompileSourceCodeRequest* MessageFrame::unsafe_arena_release_compile_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.compile_request)
  if (_internal_has_compile_request()) {
    clear_has_body();
    ::data::CompileSourceCodeRequest* temp = _impl_.body_.compile_request_;
    _impl_.body_.compile_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_compile_request(::data::CompileSourceCodeRequest* compile_request) {
  clear_body();
  if (compile_request) {
    set_has_compile_request();
    _impl_.body_.compile_request_ = compile_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.compile_request)
}
inline ::data::CompileSourceCodeRequest* MessageFrame::_internal_mutable_compile_request() {
  if (!_internal_has_compile_request()) {
    clear_body();
    set_has_compile_request();
    _impl_.body_.compile_request_ = CreateMaybeMessage< ::data::CompileSourceCodeRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.compile_request_;
}
inline ::data::CompileSourceCodeRequest* MessageFrame::mutable_compile_request() {
  ::data::CompileSourceCodeRequest* _msg = _internal_mutable_compile_request();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.compile_request)
  return _msg;
}

// .data.CompileSourceCodeResponse compile_response = 11;
inline bool MessageFrame::_internal_has_compile_response() const {
  return body_case() == kCompileResponse;
}
inline bool MessageFrame::has_compile_response() const {
  return _internal_has_compile_response();
}
inline void MessageFrame::set_has_compile_response() {
  _impl_._oneof_case_[0] = kCompileResponse;
}
inline void MessageFrame::clear_compile_response() {
  if (_internal_has_compile_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.compile_response_;
    }
    clear_has_body();
  }
}
inline ::data::CompileSourceCodeResponse* MessageFrame::release_compile_response() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.compile_response)
  if (_internal_has_compile_response()) {
    clear_has_body();
    ::data::CompileSourceCodeResponse* temp = _impl_.body_.compile_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.compile_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::CompileSourceCodeResponse& MessageFrame::_internal_compile_response() const {
  return _internal_has_compile_response()
      ? *_impl_.body_.compile_response_
      : reinterpret_cast< ::data::CompileSourceCodeResponse&>(::data::_CompileSourceCodeResponse_default_instance_);
}
inline const ::data::CompileSourceCodeResponse& MessageFrame::compile_response() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.compile_response)
  return _internal_compile_response();
}
inline ::data::CompileSourceCodeResponse* MessageFrame::unsafe_arena_release_compile_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.compile_response)
  if (_internal_has_compile_response()) {
    clear_has_body();
    ::data::CompileSourceCodeResponse* temp = _impl_.body_.compile_response_;
    _impl_.body_.compile_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_compile_response(::data::CompileSourceCodeResponse* compile_response) {
  clear_body();
  if (compile_response) {
    set_has_compile_response();
    _impl_.body_.compile_response_ = compile_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.compile_response)
}
inline ::data::CompileSourceCodeResponse* MessageFrame::_internal_mutable_compile_response() {
  if (!_internal_has_compile_response()) {
    clear_body();
    set_has_compile_response();
    _impl_.body_.compile_response_ = CreateMaybeMessage< ::data::CompileSourceCodeResponse >(GetArenaForAllocation());
  }
  return _impl_.body_.compile_response_;
}
inline ::data::CompileSourceCodeResponse* MessageFrame::mutable_compile_response() {
  ::data::CompileSourceCodeResponse* _msg = _internal_mutable_compile_response();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.compile_response)
  return _msg;
}

// .data.ExecuteIRCodeRequest execute_ir_request = 12;
inline bool MessageFrame::_internal_has_execute_ir_request() const {
  return body_case() == kExecuteIrRequest;
}
inline bool MessageFrame::has_execute_ir_request() const {
  return _internal_has_execute_ir_request();
}
inline void MessageFrame::set_has_execute_ir_request() {
  _impl_._oneof_case_[0] = kExecuteIrRequest;
}
inline void MessageFrame::clear_execute_ir_request() {
  if (_internal_has_execute_ir_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.execute_ir_request_;
    }
    clear_has_body();
  }
}
inline ::data::ExecuteIRCodeRequest* MessageFrame::release_execute_ir_request() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.execute_ir_request)
  if (_internal_has_execute_ir_request()) {
    clear_has_body();
    ::data::ExecuteIRCodeRequest* temp = _impl_.body_.execute_ir_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.execute_ir_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::ExecuteIRCodeRequest& MessageFrame::_internal_execute_ir_request() const {
  return _internal_has_execute_ir_request()
      ? *_impl_.body_.execute_ir_request_
      : reinterpret_cast< ::data::ExecuteIRCodeRequest&>(::data::_ExecuteIRCodeRequest_default_instance_);
}
inline const ::data::ExecuteIRCodeRequest& MessageFrame::execute_ir_request() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.execute_ir_request)
  return _internal_execute_ir_request();
}
inline ::data::ExecuteIRCodeRequest* MessageFrame::unsafe_arena_release_execute_ir_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.execute_ir_request)
  if (_internal_has_execute_ir_request()) {
    clear_has_body();
    ::data::ExecuteIRCodeRequest* temp = _impl_.body_.execute_ir_request_;
    _impl_.body_.execute_ir_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_execute_ir_request(::data::ExecuteIRCodeRequest* execute_ir_request) {
  clear_body();
  if (execute_ir_request) {
    set_has_execute_ir_request();
    _impl_.body_.execute_ir_request_ = execute_ir_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.execute_ir_request)
}
inline ::data::ExecuteIRCodeRequest* MessageFrame::_internal_mutable_execute_ir_request() {
  if (!_internal_has_execute_ir_request()) {
    clear_body();
    set_has_execute_ir_request();
    _impl_.body_.execute_ir_request_ = CreateMaybeMessage< ::data::ExecuteIRCodeRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.execute_ir_request_;
}
inline ::data::ExecuteIRCodeRequest* MessageFrame::mutable_execute_ir_request() {
  ::data::ExecuteIRCodeRequest* _msg = _internal_mutable_execute_ir_request();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.execute_ir_request)
  return _msg;
}

// .data.ExecuteIRCodeResponse execute_ir_response = 13;
inline bool MessageFrame::_internal_has_execute_ir_response() const {
  return body_case() == kExecuteIrResponse;
}
inline bool MessageFrame::has_execute_ir_response() const {
  return _internal_has_execute_ir_response();
}
inline void MessageFrame::set_has_execute_ir_response() {
  _impl_._oneof_case_[0] = kExecuteIrResponse;
}
inline void MessageFrame::clear_execute_ir_response() {
  if (_internal_has_execute_ir_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.execute_ir_response_;
    }
    clear_has_body();
  }
}
inline ::data::ExecuteIRCodeResponse* MessageFrame::release_execute_ir_response() {
  // @@protoc_insertion_point(field_release:data.MessageFrame.execute_ir_response)
  if (_internal_has_execute_ir_response()) {
    clear_has_body();
    ::data::ExecuteIRCodeResponse* temp = _impl_.body_.execute_ir_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.execute_ir_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::data::ExecuteIRCodeResponse& MessageFrame::_internal_execute_ir_response() const {
  return _internal_has_execute_ir_response()
      ? *_impl_.body_.execute_ir_response_
      : reinterpret_cast< ::data::ExecuteIRCodeResponse&>(::data::_ExecuteIRCodeResponse_default_instance_);
}
inline const ::data::ExecuteIRCodeResponse& MessageFrame::execute_ir_response() const {
  // @@protoc_insertion_point(field_get:data.MessageFrame.execute_ir_response)
  return _internal_execute_ir_response();
}
inline ::data::ExecuteIRCodeResponse* MessageFrame::unsafe_arena_release_execute_ir_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:data.MessageFrame.execute_ir_response)
  if (_internal_has_execute_ir_response()) {
    clear_has_body();
    ::data::ExecuteIRCodeResponse* temp = _impl_.body_.execute_ir_response_;
    _impl_.body_.execute_ir_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFrame::unsafe_arena_set_allocated_execute_ir_response(::data::ExecuteIRCodeResponse* execute_ir_response) {
  clear_body();
  if (execute_ir_response) {
    set_has_execute_ir_response();
    _impl_.body_.execute_ir_response_ = execute_ir_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data.MessageFrame.execute_ir_response)
}
inline ::data::ExecuteIRCodeResponse* MessageFrame::_internal_mutable_execute_ir_response() {
  if (!_internal_has_execute_ir_response()) {
    clear_body();
    set_has_execute_ir_response();
    _impl_.body_.execute_ir_response_ = CreateMaybeMessage< ::data::ExecuteIRCodeResponse >(GetArenaForAllocation());
  }
  return _impl_.body_.execute_ir_response_;
}
inline ::data::ExecuteIRCodeResponse* MessageFrame::mutable_execute_ir_response() {
  ::data::ExecuteIRCodeResponse* _msg = _internal_mutable_execute_ir_response();
  // @@protoc_insertion_point(field_mutable:data.MessageFrame.execute_ir_response)
  return _msg;
}

inline bool MessageFrame::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void MessageFrame::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline MessageFrame::BodyCase MessageFrame::body_case() const {
  return MessageFrame::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:data.LoginRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:data.LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:data.LoginRequest.username)
  return _impl_.username_.Release();
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LoginRequest.username)
}

// string password_hash = 2;
inline void LoginRequest::clear_password_hash() {
  _impl_.password_hash_.ClearToEmpty();
}
inline const std::string& LoginRequest::password_hash() const {
  // @@protoc_insertion_point(field_get:data.LoginRequest.password_hash)
  return _internal_password_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LoginRequest.password_hash)
}
inline std::string* LoginRequest::mutable_password_hash() {
  std::string* _s = _internal_mutable_password_hash();
  // @@protoc_insertion_point(field_mutable:data.LoginRequest.password_hash)
  return _s;
}
inline const std::string& LoginRequest::_internal_password_hash() const {
  return _impl_.password_hash_.Get();
}
inline void LoginRequest::_internal_set_password_hash(const std::string& value) {
  
  _impl_.password_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password_hash() {
  
  return _impl_.password_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password_hash() {
  // @@protoc_insertion_point(field_release:data.LoginRequest.password_hash)
  return _impl_.password_hash_.Release();
}
inline void LoginRequest::set_allocated_password_hash(std::string* password_hash) {
  if (password_hash != nullptr) {
    
  } else {
    
  }
  _impl_.password_hash_.SetAllocated(password_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_hash_.IsDefault()) {
    _impl_.password_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LoginRequest.password_hash)
}

// string device_info = 3;
inline void LoginRequest::clear_device_info() {
  _impl_.device_info_.ClearToEmpty();
}
inline const std::string& LoginRequest::device_info() const {
  // @@protoc_insertion_point(field_get:data.LoginRequest.device_info)
  return _internal_device_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_device_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LoginRequest.device_info)
}
inline std::string* LoginRequest::mutable_device_info() {
  std::string* _s = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:data.LoginRequest.device_info)
  return _s;
}
inline const std::string& LoginRequest::_internal_device_info() const {
  return _impl_.device_info_.Get();
}
inline void LoginRequest::_internal_set_device_info(const std::string& value) {
  
  _impl_.device_info_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_device_info() {
  
  return _impl_.device_info_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_device_info() {
  // @@protoc_insertion_point(field_release:data.LoginRequest.device_info)
  return _impl_.device_info_.Release();
}
inline void LoginRequest::set_allocated_device_info(std::string* device_info) {
  if (device_info != nullptr) {
    
  } else {
    
  }
  _impl_.device_info_.SetAllocated(device_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_info_.IsDefault()) {
    _impl_.device_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LoginRequest.device_info)
}

// string app_version = 4;
inline void LoginRequest::clear_app_version() {
  _impl_.app_version_.ClearToEmpty();
}
inline const std::string& LoginRequest::app_version() const {
  // @@protoc_insertion_point(field_get:data.LoginRequest.app_version)
  return _internal_app_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_app_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.app_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LoginRequest.app_version)
}
inline std::string* LoginRequest::mutable_app_version() {
  std::string* _s = _internal_mutable_app_version();
  // @@protoc_insertion_point(field_mutable:data.LoginRequest.app_version)
  return _s;
}
inline const std::string& LoginRequest::_internal_app_version() const {
  return _impl_.app_version_.Get();
}
inline void LoginRequest::_internal_set_app_version(const std::string& value) {
  
  _impl_.app_version_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_app_version() {
  
  return _impl_.app_version_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_app_version() {
  // @@protoc_insertion_point(field_release:data.LoginRequest.app_version)
  return _impl_.app_version_.Release();
}
inline void LoginRequest::set_allocated_app_version(std::string* app_version) {
  if (app_version != nullptr) {
    
  } else {
    
  }
  _impl_.app_version_.SetAllocated(app_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_version_.IsDefault()) {
    _impl_.app_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LoginRequest.app_version)
}

// string token = 5;
inline void LoginRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& LoginRequest::token() const {
  // @@protoc_insertion_point(field_get:data.LoginRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LoginRequest.token)
}
inline std::string* LoginRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:data.LoginRequest.token)
  return _s;
}
inline const std::string& LoginRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LoginRequest::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_token() {
  // @@protoc_insertion_point(field_release:data.LoginRequest.token)
  return _impl_.token_.Release();
}
inline void LoginRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LoginRequest.token)
}

// -------------------------------------------------------------------

// LoginResponse

// bool success = 1;
inline void LoginResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool LoginResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool LoginResponse::success() const {
  // @@protoc_insertion_point(field_get:data.LoginResponse.success)
  return _internal_success();
}
inline void LoginResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void LoginResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:data.LoginResponse.success)
}

// string session_id = 2;
inline void LoginResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& LoginResponse::session_id() const {
  // @@protoc_insertion_point(field_get:data.LoginResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LoginResponse.session_id)
}
inline std::string* LoginResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:data.LoginResponse.session_id)
  return _s;
}
inline const std::string& LoginResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void LoginResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:data.LoginResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void LoginResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LoginResponse.session_id)
}

// uint64 expire_time = 3;
inline void LoginResponse::clear_expire_time() {
  _impl_.expire_time_ = uint64_t{0u};
}
inline uint64_t LoginResponse::_internal_expire_time() const {
  return _impl_.expire_time_;
}
inline uint64_t LoginResponse::expire_time() const {
  // @@protoc_insertion_point(field_get:data.LoginResponse.expire_time)
  return _internal_expire_time();
}
inline void LoginResponse::_internal_set_expire_time(uint64_t value) {
  
  _impl_.expire_time_ = value;
}
inline void LoginResponse::set_expire_time(uint64_t value) {
  _internal_set_expire_time(value);
  // @@protoc_insertion_point(field_set:data.LoginResponse.expire_time)
}

// string user_nickname = 4;
inline void LoginResponse::clear_user_nickname() {
  _impl_.user_nickname_.ClearToEmpty();
}
inline const std::string& LoginResponse::user_nickname() const {
  // @@protoc_insertion_point(field_get:data.LoginResponse.user_nickname)
  return _internal_user_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_user_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.LoginResponse.user_nickname)
}
inline std::string* LoginResponse::mutable_user_nickname() {
  std::string* _s = _internal_mutable_user_nickname();
  // @@protoc_insertion_point(field_mutable:data.LoginResponse.user_nickname)
  return _s;
}
inline const std::string& LoginResponse::_internal_user_nickname() const {
  return _impl_.user_nickname_.Get();
}
inline void LoginResponse::_internal_set_user_nickname(const std::string& value) {
  
  _impl_.user_nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_user_nickname() {
  
  return _impl_.user_nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_user_nickname() {
  // @@protoc_insertion_point(field_release:data.LoginResponse.user_nickname)
  return _impl_.user_nickname_.Release();
}
inline void LoginResponse::set_allocated_user_nickname(std::string* user_nickname) {
  if (user_nickname != nullptr) {
    
  } else {
    
  }
  _impl_.user_nickname_.SetAllocated(user_nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_nickname_.IsDefault()) {
    _impl_.user_nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.LoginResponse.user_nickname)
}

// uint32 user_role = 5;
inline void LoginResponse::clear_user_role() {
  _impl_.user_role_ = 0u;
}
inline uint32_t LoginResponse::_internal_user_role() const {
  return _impl_.user_role_;
}
inline uint32_t LoginResponse::user_role() const {
  // @@protoc_insertion_point(field_get:data.LoginResponse.user_role)
  return _internal_user_role();
}
inline void LoginResponse::_internal_set_user_role(uint32_t value) {
  
  _impl_.user_role_ = value;
}
inline void LoginResponse::set_user_role(uint32_t value) {
  _internal_set_user_role(value);
  // @@protoc_insertion_point(field_set:data.LoginResponse.user_role)
}

// -------------------------------------------------------------------

// Heartbeat

// uint64 last_active_time = 1;
inline void Heartbeat::clear_last_active_time() {
  _impl_.last_active_time_ = uint64_t{0u};
}
inline uint64_t Heartbeat::_internal_last_active_time() const {
  return _impl_.last_active_time_;
}
inline uint64_t Heartbeat::last_active_time() const {
  // @@protoc_insertion_point(field_get:data.Heartbeat.last_active_time)
  return _internal_last_active_time();
}
inline void Heartbeat::_internal_set_last_active_time(uint64_t value) {
  
  _impl_.last_active_time_ = value;
}
inline void Heartbeat::set_last_active_time(uint64_t value) {
  _internal_set_last_active_time(value);
  // @@protoc_insertion_point(field_set:data.Heartbeat.last_active_time)
}

// uint64 server_time = 2;
inline void Heartbeat::clear_server_time() {
  _impl_.server_time_ = uint64_t{0u};
}
inline uint64_t Heartbeat::_internal_server_time() const {
  return _impl_.server_time_;
}
inline uint64_t Heartbeat::server_time() const {
  // @@protoc_insertion_point(field_get:data.Heartbeat.server_time)
  return _internal_server_time();
}
inline void Heartbeat::_internal_set_server_time(uint64_t value) {
  
  _impl_.server_time_ = value;
}
inline void Heartbeat::set_server_time(uint64_t value) {
  _internal_set_server_time(value);
  // @@protoc_insertion_point(field_set:data.Heartbeat.server_time)
}

// string connection_status = 3;
inline void Heartbeat::clear_connection_status() {
  _impl_.connection_status_.ClearToEmpty();
}
inline const std::string& Heartbeat::connection_status() const {
  // @@protoc_insertion_point(field_get:data.Heartbeat.connection_status)
  return _internal_connection_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Heartbeat::set_connection_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connection_status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.Heartbeat.connection_status)
}
inline std::string* Heartbeat::mutable_connection_status() {
  std::string* _s = _internal_mutable_connection_status();
  // @@protoc_insertion_point(field_mutable:data.Heartbeat.connection_status)
  return _s;
}
inline const std::string& Heartbeat::_internal_connection_status() const {
  return _impl_.connection_status_.Get();
}
inline void Heartbeat::_internal_set_connection_status(const std::string& value) {
  
  _impl_.connection_status_.Set(value, GetArenaForAllocation());
}
inline std::string* Heartbeat::_internal_mutable_connection_status() {
  
  return _impl_.connection_status_.Mutable(GetArenaForAllocation());
}
inline std::string* Heartbeat::release_connection_status() {
  // @@protoc_insertion_point(field_release:data.Heartbeat.connection_status)
  return _impl_.connection_status_.Release();
}
inline void Heartbeat::set_allocated_connection_status(std::string* connection_status) {
  if (connection_status != nullptr) {
    
  } else {
    
  }
  _impl_.connection_status_.SetAllocated(connection_status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connection_status_.IsDefault()) {
    _impl_.connection_status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.Heartbeat.connection_status)
}

// -------------------------------------------------------------------

// ErrorResponse

// .common.ErrorCode common_code = 1;
inline bool ErrorResponse::_internal_has_common_code() const {
  return ErrorCode_case() == kCommonCode;
}
inline bool ErrorResponse::has_common_code() const {
  return _internal_has_common_code();
}
inline void ErrorResponse::set_has_common_code() {
  _impl_._oneof_case_[0] = kCommonCode;
}
inline void ErrorResponse::clear_common_code() {
  if (_internal_has_common_code()) {
    _impl_.ErrorCode_.common_code_ = 0;
    clear_has_ErrorCode();
  }
}
inline ::common::ErrorCode ErrorResponse::_internal_common_code() const {
  if (_internal_has_common_code()) {
    return static_cast< ::common::ErrorCode >(_impl_.ErrorCode_.common_code_);
  }
  return static_cast< ::common::ErrorCode >(0);
}
inline ::common::ErrorCode ErrorResponse::common_code() const {
  // @@protoc_insertion_point(field_get:data.ErrorResponse.common_code)
  return _internal_common_code();
}
inline void ErrorResponse::_internal_set_common_code(::common::ErrorCode value) {
  if (!_internal_has_common_code()) {
    clear_ErrorCode();
    set_has_common_code();
  }
  _impl_.ErrorCode_.common_code_ = value;
}
inline void ErrorResponse::set_common_code(::common::ErrorCode value) {
  _internal_set_common_code(value);
  // @@protoc_insertion_point(field_set:data.ErrorResponse.common_code)
}

// .network.ErrorCode network_code = 2;
inline bool ErrorResponse::_internal_has_network_code() const {
  return ErrorCode_case() == kNetworkCode;
}
inline bool ErrorResponse::has_network_code() const {
  return _internal_has_network_code();
}
inline void ErrorResponse::set_has_network_code() {
  _impl_._oneof_case_[0] = kNetworkCode;
}
inline void ErrorResponse::clear_network_code() {
  if (_internal_has_network_code()) {
    _impl_.ErrorCode_.network_code_ = 0;
    clear_has_ErrorCode();
  }
}
inline ::network::ErrorCode ErrorResponse::_internal_network_code() const {
  if (_internal_has_network_code()) {
    return static_cast< ::network::ErrorCode >(_impl_.ErrorCode_.network_code_);
  }
  return static_cast< ::network::ErrorCode >(0);
}
inline ::network::ErrorCode ErrorResponse::network_code() const {
  // @@protoc_insertion_point(field_get:data.ErrorResponse.network_code)
  return _internal_network_code();
}
inline void ErrorResponse::_internal_set_network_code(::network::ErrorCode value) {
  if (!_internal_has_network_code()) {
    clear_ErrorCode();
    set_has_network_code();
  }
  _impl_.ErrorCode_.network_code_ = value;
}
inline void ErrorResponse::set_network_code(::network::ErrorCode value) {
  _internal_set_network_code(value);
  // @@protoc_insertion_point(field_set:data.ErrorResponse.network_code)
}

// string message = 13;
inline void ErrorResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ErrorResponse::message() const {
  // @@protoc_insertion_point(field_get:data.ErrorResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ErrorResponse.message)
}
inline std::string* ErrorResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:data.ErrorResponse.message)
  return _s;
}
inline const std::string& ErrorResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ErrorResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorResponse::release_message() {
  // @@protoc_insertion_point(field_release:data.ErrorResponse.message)
  return _impl_.message_.Release();
}
inline void ErrorResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ErrorResponse.message)
}

// string detail = 3;
inline void ErrorResponse::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& ErrorResponse::detail() const {
  // @@protoc_insertion_point(field_get:data.ErrorResponse.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorResponse::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ErrorResponse.detail)
}
inline std::string* ErrorResponse::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:data.ErrorResponse.detail)
  return _s;
}
inline const std::string& ErrorResponse::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void ErrorResponse::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorResponse::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorResponse::release_detail() {
  // @@protoc_insertion_point(field_release:data.ErrorResponse.detail)
  return _impl_.detail_.Release();
}
inline void ErrorResponse::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ErrorResponse.detail)
}

// string solution = 4;
inline void ErrorResponse::clear_solution() {
  _impl_.solution_.ClearToEmpty();
}
inline const std::string& ErrorResponse::solution() const {
  // @@protoc_insertion_point(field_get:data.ErrorResponse.solution)
  return _internal_solution();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorResponse::set_solution(ArgT0&& arg0, ArgT... args) {
 
 _impl_.solution_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ErrorResponse.solution)
}
inline std::string* ErrorResponse::mutable_solution() {
  std::string* _s = _internal_mutable_solution();
  // @@protoc_insertion_point(field_mutable:data.ErrorResponse.solution)
  return _s;
}
inline const std::string& ErrorResponse::_internal_solution() const {
  return _impl_.solution_.Get();
}
inline void ErrorResponse::_internal_set_solution(const std::string& value) {
  
  _impl_.solution_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorResponse::_internal_mutable_solution() {
  
  return _impl_.solution_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorResponse::release_solution() {
  // @@protoc_insertion_point(field_release:data.ErrorResponse.solution)
  return _impl_.solution_.Release();
}
inline void ErrorResponse::set_allocated_solution(std::string* solution) {
  if (solution != nullptr) {
    
  } else {
    
  }
  _impl_.solution_.SetAllocated(solution, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.solution_.IsDefault()) {
    _impl_.solution_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ErrorResponse.solution)
}

// string request_type = 5;
inline void ErrorResponse::clear_request_type() {
  _impl_.request_type_.ClearToEmpty();
}
inline const std::string& ErrorResponse::request_type() const {
  // @@protoc_insertion_point(field_get:data.ErrorResponse.request_type)
  return _internal_request_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorResponse::set_request_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ErrorResponse.request_type)
}
inline std::string* ErrorResponse::mutable_request_type() {
  std::string* _s = _internal_mutable_request_type();
  // @@protoc_insertion_point(field_mutable:data.ErrorResponse.request_type)
  return _s;
}
inline const std::string& ErrorResponse::_internal_request_type() const {
  return _impl_.request_type_.Get();
}
inline void ErrorResponse::_internal_set_request_type(const std::string& value) {
  
  _impl_.request_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorResponse::_internal_mutable_request_type() {
  
  return _impl_.request_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorResponse::release_request_type() {
  // @@protoc_insertion_point(field_release:data.ErrorResponse.request_type)
  return _impl_.request_type_.Release();
}
inline void ErrorResponse::set_allocated_request_type(std::string* request_type) {
  if (request_type != nullptr) {
    
  } else {
    
  }
  _impl_.request_type_.SetAllocated(request_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_type_.IsDefault()) {
    _impl_.request_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ErrorResponse.request_type)
}

inline bool ErrorResponse::has_ErrorCode() const {
  return ErrorCode_case() != ERRORCODE_NOT_SET;
}
inline void ErrorResponse::clear_has_ErrorCode() {
  _impl_._oneof_case_[0] = ERRORCODE_NOT_SET;
}
inline ErrorResponse::ErrorCodeCase ErrorResponse::ErrorCode_case() const {
  return ErrorResponse::ErrorCodeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Notification

// .data.Notification.NotifyType type = 1;
inline void Notification::clear_type() {
  _impl_.type_ = 0;
}
inline ::data::Notification_NotifyType Notification::_internal_type() const {
  return static_cast< ::data::Notification_NotifyType >(_impl_.type_);
}
inline ::data::Notification_NotifyType Notification::type() const {
  // @@protoc_insertion_point(field_get:data.Notification.type)
  return _internal_type();
}
inline void Notification::_internal_set_type(::data::Notification_NotifyType value) {
  
  _impl_.type_ = value;
}
inline void Notification::set_type(::data::Notification_NotifyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:data.Notification.type)
}

// string content = 2;
inline void Notification::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Notification::content() const {
  // @@protoc_insertion_point(field_get:data.Notification.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.Notification.content)
}
inline std::string* Notification::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:data.Notification.content)
  return _s;
}
inline const std::string& Notification::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Notification::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_content() {
  // @@protoc_insertion_point(field_release:data.Notification.content)
  return _impl_.content_.Release();
}
inline void Notification::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.Notification.content)
}

// uint64 create_time = 3;
inline void Notification::clear_create_time() {
  _impl_.create_time_ = uint64_t{0u};
}
inline uint64_t Notification::_internal_create_time() const {
  return _impl_.create_time_;
}
inline uint64_t Notification::create_time() const {
  // @@protoc_insertion_point(field_get:data.Notification.create_time)
  return _internal_create_time();
}
inline void Notification::_internal_set_create_time(uint64_t value) {
  
  _impl_.create_time_ = value;
}
inline void Notification::set_create_time(uint64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:data.Notification.create_time)
}

// bool need_ack = 4;
inline void Notification::clear_need_ack() {
  _impl_.need_ack_ = false;
}
inline bool Notification::_internal_need_ack() const {
  return _impl_.need_ack_;
}
inline bool Notification::need_ack() const {
  // @@protoc_insertion_point(field_get:data.Notification.need_ack)
  return _internal_need_ack();
}
inline void Notification::_internal_set_need_ack(bool value) {
  
  _impl_.need_ack_ = value;
}
inline void Notification::set_need_ack(bool value) {
  _internal_set_need_ack(value);
  // @@protoc_insertion_point(field_set:data.Notification.need_ack)
}

// -------------------------------------------------------------------

// BatchRequest

// repeated .data.MessageFrame sub_requests = 1;
inline int BatchRequest::_internal_sub_requests_size() const {
  return _impl_.sub_requests_.size();
}
inline int BatchRequest::sub_requests_size() const {
  return _internal_sub_requests_size();
}
inline void BatchRequest::clear_sub_requests() {
  _impl_.sub_requests_.Clear();
}
inline ::data::MessageFrame* BatchRequest::mutable_sub_requests(int index) {
  // @@protoc_insertion_point(field_mutable:data.BatchRequest.sub_requests)
  return _impl_.sub_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::MessageFrame >*
BatchRequest::mutable_sub_requests() {
  // @@protoc_insertion_point(field_mutable_list:data.BatchRequest.sub_requests)
  return &_impl_.sub_requests_;
}
inline const ::data::MessageFrame& BatchRequest::_internal_sub_requests(int index) const {
  return _impl_.sub_requests_.Get(index);
}
inline const ::data::MessageFrame& BatchRequest::sub_requests(int index) const {
  // @@protoc_insertion_point(field_get:data.BatchRequest.sub_requests)
  return _internal_sub_requests(index);
}
inline ::data::MessageFrame* BatchRequest::_internal_add_sub_requests() {
  return _impl_.sub_requests_.Add();
}
inline ::data::MessageFrame* BatchRequest::add_sub_requests() {
  ::data::MessageFrame* _add = _internal_add_sub_requests();
  // @@protoc_insertion_point(field_add:data.BatchRequest.sub_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::data::MessageFrame >&
BatchRequest::sub_requests() const {
  // @@protoc_insertion_point(field_list:data.BatchRequest.sub_requests)
  return _impl_.sub_requests_;
}

// bool need_atomic = 2;
inline void BatchRequest::clear_need_atomic() {
  _impl_.need_atomic_ = false;
}
inline bool BatchRequest::_internal_need_atomic() const {
  return _impl_.need_atomic_;
}
inline bool BatchRequest::need_atomic() const {
  // @@protoc_insertion_point(field_get:data.BatchRequest.need_atomic)
  return _internal_need_atomic();
}
inline void BatchRequest::_internal_set_need_atomic(bool value) {
  
  _impl_.need_atomic_ = value;
}
inline void BatchRequest::set_need_atomic(bool value) {
  _internal_set_need_atomic(value);
  // @@protoc_insertion_point(field_set:data.BatchRequest.need_atomic)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SaveSourceCodeRequest

// string code_id = 1;
inline void SaveSourceCodeRequest::clear_code_id() {
  _impl_.code_id_.ClearToEmpty();
}
inline const std::string& SaveSourceCodeRequest::code_id() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeRequest.code_id)
  return _internal_code_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSourceCodeRequest::set_code_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeRequest.code_id)
}
inline std::string* SaveSourceCodeRequest::mutable_code_id() {
  std::string* _s = _internal_mutable_code_id();
  // @@protoc_insertion_point(field_mutable:data.SaveSourceCodeRequest.code_id)
  return _s;
}
inline const std::string& SaveSourceCodeRequest::_internal_code_id() const {
  return _impl_.code_id_.Get();
}
inline void SaveSourceCodeRequest::_internal_set_code_id(const std::string& value) {
  
  _impl_.code_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::_internal_mutable_code_id() {
  
  return _impl_.code_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::release_code_id() {
  // @@protoc_insertion_point(field_release:data.SaveSourceCodeRequest.code_id)
  return _impl_.code_id_.Release();
}
inline void SaveSourceCodeRequest::set_allocated_code_id(std::string* code_id) {
  if (code_id != nullptr) {
    
  } else {
    
  }
  _impl_.code_id_.SetAllocated(code_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_id_.IsDefault()) {
    _impl_.code_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SaveSourceCodeRequest.code_id)
}

// string language = 2;
inline void SaveSourceCodeRequest::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& SaveSourceCodeRequest::language() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeRequest.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSourceCodeRequest::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeRequest.language)
}
inline std::string* SaveSourceCodeRequest::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:data.SaveSourceCodeRequest.language)
  return _s;
}
inline const std::string& SaveSourceCodeRequest::_internal_language() const {
  return _impl_.language_.Get();
}
inline void SaveSourceCodeRequest::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::release_language() {
  // @@protoc_insertion_point(field_release:data.SaveSourceCodeRequest.language)
  return _impl_.language_.Release();
}
inline void SaveSourceCodeRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SaveSourceCodeRequest.language)
}

// string source_code = 3;
inline void SaveSourceCodeRequest::clear_source_code() {
  _impl_.source_code_.ClearToEmpty();
}
inline const std::string& SaveSourceCodeRequest::source_code() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeRequest.source_code)
  return _internal_source_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSourceCodeRequest::set_source_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeRequest.source_code)
}
inline std::string* SaveSourceCodeRequest::mutable_source_code() {
  std::string* _s = _internal_mutable_source_code();
  // @@protoc_insertion_point(field_mutable:data.SaveSourceCodeRequest.source_code)
  return _s;
}
inline const std::string& SaveSourceCodeRequest::_internal_source_code() const {
  return _impl_.source_code_.Get();
}
inline void SaveSourceCodeRequest::_internal_set_source_code(const std::string& value) {
  
  _impl_.source_code_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::_internal_mutable_source_code() {
  
  return _impl_.source_code_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::release_source_code() {
  // @@protoc_insertion_point(field_release:data.SaveSourceCodeRequest.source_code)
  return _impl_.source_code_.Release();
}
inline void SaveSourceCodeRequest::set_allocated_source_code(std::string* source_code) {
  if (source_code != nullptr) {
    
  } else {
    
  }
  _impl_.source_code_.SetAllocated(source_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_code_.IsDefault()) {
    _impl_.source_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SaveSourceCodeRequest.source_code)
}

// string code_name = 4;
inline void SaveSourceCodeRequest::clear_code_name() {
  _impl_.code_name_.ClearToEmpty();
}
inline const std::string& SaveSourceCodeRequest::code_name() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeRequest.code_name)
  return _internal_code_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSourceCodeRequest::set_code_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeRequest.code_name)
}
inline std::string* SaveSourceCodeRequest::mutable_code_name() {
  std::string* _s = _internal_mutable_code_name();
  // @@protoc_insertion_point(field_mutable:data.SaveSourceCodeRequest.code_name)
  return _s;
}
inline const std::string& SaveSourceCodeRequest::_internal_code_name() const {
  return _impl_.code_name_.Get();
}
inline void SaveSourceCodeRequest::_internal_set_code_name(const std::string& value) {
  
  _impl_.code_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::_internal_mutable_code_name() {
  
  return _impl_.code_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::release_code_name() {
  // @@protoc_insertion_point(field_release:data.SaveSourceCodeRequest.code_name)
  return _impl_.code_name_.Release();
}
inline void SaveSourceCodeRequest::set_allocated_code_name(std::string* code_name) {
  if (code_name != nullptr) {
    
  } else {
    
  }
  _impl_.code_name_.SetAllocated(code_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_name_.IsDefault()) {
    _impl_.code_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SaveSourceCodeRequest.code_name)
}

// string description = 5;
inline void SaveSourceCodeRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SaveSourceCodeRequest::description() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSourceCodeRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeRequest.description)
}
inline std::string* SaveSourceCodeRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:data.SaveSourceCodeRequest.description)
  return _s;
}
inline const std::string& SaveSourceCodeRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SaveSourceCodeRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSourceCodeRequest::release_description() {
  // @@protoc_insertion_point(field_release:data.SaveSourceCodeRequest.description)
  return _impl_.description_.Release();
}
inline void SaveSourceCodeRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SaveSourceCodeRequest.description)
}

// map<string, string> metadata = 6;
inline int SaveSourceCodeRequest::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int SaveSourceCodeRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void SaveSourceCodeRequest::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SaveSourceCodeRequest::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SaveSourceCodeRequest::metadata() const {
  // @@protoc_insertion_point(field_map:data.SaveSourceCodeRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SaveSourceCodeRequest::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SaveSourceCodeRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:data.SaveSourceCodeRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// SaveSourceCodeResponse

// bool success = 1;
inline void SaveSourceCodeResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool SaveSourceCodeResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SaveSourceCodeResponse::success() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeResponse.success)
  return _internal_success();
}
inline void SaveSourceCodeResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SaveSourceCodeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeResponse.success)
}

// string code_id = 2;
inline void SaveSourceCodeResponse::clear_code_id() {
  _impl_.code_id_.ClearToEmpty();
}
inline const std::string& SaveSourceCodeResponse::code_id() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeResponse.code_id)
  return _internal_code_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSourceCodeResponse::set_code_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeResponse.code_id)
}
inline std::string* SaveSourceCodeResponse::mutable_code_id() {
  std::string* _s = _internal_mutable_code_id();
  // @@protoc_insertion_point(field_mutable:data.SaveSourceCodeResponse.code_id)
  return _s;
}
inline const std::string& SaveSourceCodeResponse::_internal_code_id() const {
  return _impl_.code_id_.Get();
}
inline void SaveSourceCodeResponse::_internal_set_code_id(const std::string& value) {
  
  _impl_.code_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSourceCodeResponse::_internal_mutable_code_id() {
  
  return _impl_.code_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSourceCodeResponse::release_code_id() {
  // @@protoc_insertion_point(field_release:data.SaveSourceCodeResponse.code_id)
  return _impl_.code_id_.Release();
}
inline void SaveSourceCodeResponse::set_allocated_code_id(std::string* code_id) {
  if (code_id != nullptr) {
    
  } else {
    
  }
  _impl_.code_id_.SetAllocated(code_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_id_.IsDefault()) {
    _impl_.code_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SaveSourceCodeResponse.code_id)
}

// string message = 3;
inline void SaveSourceCodeResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SaveSourceCodeResponse::message() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSourceCodeResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeResponse.message)
}
inline std::string* SaveSourceCodeResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:data.SaveSourceCodeResponse.message)
  return _s;
}
inline const std::string& SaveSourceCodeResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SaveSourceCodeResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSourceCodeResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSourceCodeResponse::release_message() {
  // @@protoc_insertion_point(field_release:data.SaveSourceCodeResponse.message)
  return _impl_.message_.Release();
}
inline void SaveSourceCodeResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.SaveSourceCodeResponse.message)
}

// uint64 save_time = 4;
inline void SaveSourceCodeResponse::clear_save_time() {
  _impl_.save_time_ = uint64_t{0u};
}
inline uint64_t SaveSourceCodeResponse::_internal_save_time() const {
  return _impl_.save_time_;
}
inline uint64_t SaveSourceCodeResponse::save_time() const {
  // @@protoc_insertion_point(field_get:data.SaveSourceCodeResponse.save_time)
  return _internal_save_time();
}
inline void SaveSourceCodeResponse::_internal_set_save_time(uint64_t value) {
  
  _impl_.save_time_ = value;
}
inline void SaveSourceCodeResponse::set_save_time(uint64_t value) {
  _internal_set_save_time(value);
  // @@protoc_insertion_point(field_set:data.SaveSourceCodeResponse.save_time)
}

// -------------------------------------------------------------------

// CompileSourceCodeRequest

// string code_id = 1;
inline void CompileSourceCodeRequest::clear_code_id() {
  _impl_.code_id_.ClearToEmpty();
}
inline const std::string& CompileSourceCodeRequest::code_id() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeRequest.code_id)
  return _internal_code_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompileSourceCodeRequest::set_code_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeRequest.code_id)
}
inline std::string* CompileSourceCodeRequest::mutable_code_id() {
  std::string* _s = _internal_mutable_code_id();
  // @@protoc_insertion_point(field_mutable:data.CompileSourceCodeRequest.code_id)
  return _s;
}
inline const std::string& CompileSourceCodeRequest::_internal_code_id() const {
  return _impl_.code_id_.Get();
}
inline void CompileSourceCodeRequest::_internal_set_code_id(const std::string& value) {
  
  _impl_.code_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CompileSourceCodeRequest::_internal_mutable_code_id() {
  
  return _impl_.code_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CompileSourceCodeRequest::release_code_id() {
  // @@protoc_insertion_point(field_release:data.CompileSourceCodeRequest.code_id)
  return _impl_.code_id_.Release();
}
inline void CompileSourceCodeRequest::set_allocated_code_id(std::string* code_id) {
  if (code_id != nullptr) {
    
  } else {
    
  }
  _impl_.code_id_.SetAllocated(code_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_id_.IsDefault()) {
    _impl_.code_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CompileSourceCodeRequest.code_id)
}

// string compiler_options = 2;
inline void CompileSourceCodeRequest::clear_compiler_options() {
  _impl_.compiler_options_.ClearToEmpty();
}
inline const std::string& CompileSourceCodeRequest::compiler_options() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeRequest.compiler_options)
  return _internal_compiler_options();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompileSourceCodeRequest::set_compiler_options(ArgT0&& arg0, ArgT... args) {
 
 _impl_.compiler_options_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeRequest.compiler_options)
}
inline std::string* CompileSourceCodeRequest::mutable_compiler_options() {
  std::string* _s = _internal_mutable_compiler_options();
  // @@protoc_insertion_point(field_mutable:data.CompileSourceCodeRequest.compiler_options)
  return _s;
}
inline const std::string& CompileSourceCodeRequest::_internal_compiler_options() const {
  return _impl_.compiler_options_.Get();
}
inline void CompileSourceCodeRequest::_internal_set_compiler_options(const std::string& value) {
  
  _impl_.compiler_options_.Set(value, GetArenaForAllocation());
}
inline std::string* CompileSourceCodeRequest::_internal_mutable_compiler_options() {
  
  return _impl_.compiler_options_.Mutable(GetArenaForAllocation());
}
inline std::string* CompileSourceCodeRequest::release_compiler_options() {
  // @@protoc_insertion_point(field_release:data.CompileSourceCodeRequest.compiler_options)
  return _impl_.compiler_options_.Release();
}
inline void CompileSourceCodeRequest::set_allocated_compiler_options(std::string* compiler_options) {
  if (compiler_options != nullptr) {
    
  } else {
    
  }
  _impl_.compiler_options_.SetAllocated(compiler_options, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.compiler_options_.IsDefault()) {
    _impl_.compiler_options_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CompileSourceCodeRequest.compiler_options)
}

// bool optimize = 3;
inline void CompileSourceCodeRequest::clear_optimize() {
  _impl_.optimize_ = false;
}
inline bool CompileSourceCodeRequest::_internal_optimize() const {
  return _impl_.optimize_;
}
inline bool CompileSourceCodeRequest::optimize() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeRequest.optimize)
  return _internal_optimize();
}
inline void CompileSourceCodeRequest::_internal_set_optimize(bool value) {
  
  _impl_.optimize_ = value;
}
inline void CompileSourceCodeRequest::set_optimize(bool value) {
  _internal_set_optimize(value);
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeRequest.optimize)
}

// string target_ir_version = 4;
inline void CompileSourceCodeRequest::clear_target_ir_version() {
  _impl_.target_ir_version_.ClearToEmpty();
}
inline const std::string& CompileSourceCodeRequest::target_ir_version() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeRequest.target_ir_version)
  return _internal_target_ir_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompileSourceCodeRequest::set_target_ir_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_ir_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeRequest.target_ir_version)
}
inline std::string* CompileSourceCodeRequest::mutable_target_ir_version() {
  std::string* _s = _internal_mutable_target_ir_version();
  // @@protoc_insertion_point(field_mutable:data.CompileSourceCodeRequest.target_ir_version)
  return _s;
}
inline const std::string& CompileSourceCodeRequest::_internal_target_ir_version() const {
  return _impl_.target_ir_version_.Get();
}
inline void CompileSourceCodeRequest::_internal_set_target_ir_version(const std::string& value) {
  
  _impl_.target_ir_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CompileSourceCodeRequest::_internal_mutable_target_ir_version() {
  
  return _impl_.target_ir_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CompileSourceCodeRequest::release_target_ir_version() {
  // @@protoc_insertion_point(field_release:data.CompileSourceCodeRequest.target_ir_version)
  return _impl_.target_ir_version_.Release();
}
inline void CompileSourceCodeRequest::set_allocated_target_ir_version(std::string* target_ir_version) {
  if (target_ir_version != nullptr) {
    
  } else {
    
  }
  _impl_.target_ir_version_.SetAllocated(target_ir_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_ir_version_.IsDefault()) {
    _impl_.target_ir_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CompileSourceCodeRequest.target_ir_version)
}

// -------------------------------------------------------------------

// CompileSourceCodeResponse

// bool success = 1;
inline void CompileSourceCodeResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CompileSourceCodeResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CompileSourceCodeResponse::success() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeResponse.success)
  return _internal_success();
}
inline void CompileSourceCodeResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CompileSourceCodeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeResponse.success)
}

// string ir_code_id = 2;
inline void CompileSourceCodeResponse::clear_ir_code_id() {
  _impl_.ir_code_id_.ClearToEmpty();
}
inline const std::string& CompileSourceCodeResponse::ir_code_id() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeResponse.ir_code_id)
  return _internal_ir_code_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompileSourceCodeResponse::set_ir_code_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ir_code_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeResponse.ir_code_id)
}
inline std::string* CompileSourceCodeResponse::mutable_ir_code_id() {
  std::string* _s = _internal_mutable_ir_code_id();
  // @@protoc_insertion_point(field_mutable:data.CompileSourceCodeResponse.ir_code_id)
  return _s;
}
inline const std::string& CompileSourceCodeResponse::_internal_ir_code_id() const {
  return _impl_.ir_code_id_.Get();
}
inline void CompileSourceCodeResponse::_internal_set_ir_code_id(const std::string& value) {
  
  _impl_.ir_code_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CompileSourceCodeResponse::_internal_mutable_ir_code_id() {
  
  return _impl_.ir_code_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CompileSourceCodeResponse::release_ir_code_id() {
  // @@protoc_insertion_point(field_release:data.CompileSourceCodeResponse.ir_code_id)
  return _impl_.ir_code_id_.Release();
}
inline void CompileSourceCodeResponse::set_allocated_ir_code_id(std::string* ir_code_id) {
  if (ir_code_id != nullptr) {
    
  } else {
    
  }
  _impl_.ir_code_id_.SetAllocated(ir_code_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ir_code_id_.IsDefault()) {
    _impl_.ir_code_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CompileSourceCodeResponse.ir_code_id)
}

// string message = 3;
inline void CompileSourceCodeResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CompileSourceCodeResponse::message() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompileSourceCodeResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeResponse.message)
}
inline std::string* CompileSourceCodeResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:data.CompileSourceCodeResponse.message)
  return _s;
}
inline const std::string& CompileSourceCodeResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CompileSourceCodeResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CompileSourceCodeResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CompileSourceCodeResponse::release_message() {
  // @@protoc_insertion_point(field_release:data.CompileSourceCodeResponse.message)
  return _impl_.message_.Release();
}
inline void CompileSourceCodeResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.CompileSourceCodeResponse.message)
}

// uint64 compile_time = 4;
inline void CompileSourceCodeResponse::clear_compile_time() {
  _impl_.compile_time_ = uint64_t{0u};
}
inline uint64_t CompileSourceCodeResponse::_internal_compile_time() const {
  return _impl_.compile_time_;
}
inline uint64_t CompileSourceCodeResponse::compile_time() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeResponse.compile_time)
  return _internal_compile_time();
}
inline void CompileSourceCodeResponse::_internal_set_compile_time(uint64_t value) {
  
  _impl_.compile_time_ = value;
}
inline void CompileSourceCodeResponse::set_compile_time(uint64_t value) {
  _internal_set_compile_time(value);
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeResponse.compile_time)
}

// uint32 compile_duration = 5;
inline void CompileSourceCodeResponse::clear_compile_duration() {
  _impl_.compile_duration_ = 0u;
}
inline uint32_t CompileSourceCodeResponse::_internal_compile_duration() const {
  return _impl_.compile_duration_;
}
inline uint32_t CompileSourceCodeResponse::compile_duration() const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeResponse.compile_duration)
  return _internal_compile_duration();
}
inline void CompileSourceCodeResponse::_internal_set_compile_duration(uint32_t value) {
  
  _impl_.compile_duration_ = value;
}
inline void CompileSourceCodeResponse::set_compile_duration(uint32_t value) {
  _internal_set_compile_duration(value);
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeResponse.compile_duration)
}

// repeated string warnings = 6;
inline int CompileSourceCodeResponse::_internal_warnings_size() const {
  return _impl_.warnings_.size();
}
inline int CompileSourceCodeResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline void CompileSourceCodeResponse::clear_warnings() {
  _impl_.warnings_.Clear();
}
inline std::string* CompileSourceCodeResponse::add_warnings() {
  std::string* _s = _internal_add_warnings();
  // @@protoc_insertion_point(field_add_mutable:data.CompileSourceCodeResponse.warnings)
  return _s;
}
inline const std::string& CompileSourceCodeResponse::_internal_warnings(int index) const {
  return _impl_.warnings_.Get(index);
}
inline const std::string& CompileSourceCodeResponse::warnings(int index) const {
  // @@protoc_insertion_point(field_get:data.CompileSourceCodeResponse.warnings)
  return _internal_warnings(index);
}
inline std::string* CompileSourceCodeResponse::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:data.CompileSourceCodeResponse.warnings)
  return _impl_.warnings_.Mutable(index);
}
inline void CompileSourceCodeResponse::set_warnings(int index, const std::string& value) {
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeResponse.warnings)
}
inline void CompileSourceCodeResponse::set_warnings(int index, std::string&& value) {
  _impl_.warnings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:data.CompileSourceCodeResponse.warnings)
}
inline void CompileSourceCodeResponse::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:data.CompileSourceCodeResponse.warnings)
}
inline void CompileSourceCodeResponse::set_warnings(int index, const char* value, size_t size) {
  _impl_.warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.CompileSourceCodeResponse.warnings)
}
inline std::string* CompileSourceCodeResponse::_internal_add_warnings() {
  return _impl_.warnings_.Add();
}
inline void CompileSourceCodeResponse::add_warnings(const std::string& value) {
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:data.CompileSourceCodeResponse.warnings)
}
inline void CompileSourceCodeResponse::add_warnings(std::string&& value) {
  _impl_.warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:data.CompileSourceCodeResponse.warnings)
}
inline void CompileSourceCodeResponse::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:data.CompileSourceCodeResponse.warnings)
}
inline void CompileSourceCodeResponse::add_warnings(const char* value, size_t size) {
  _impl_.warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:data.CompileSourceCodeResponse.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CompileSourceCodeResponse::warnings() const {
  // @@protoc_insertion_point(field_list:data.CompileSourceCodeResponse.warnings)
  return _impl_.warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CompileSourceCodeResponse::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:data.CompileSourceCodeResponse.warnings)
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecuteIRCodeRequest

// string ir_code_id = 1;
inline void ExecuteIRCodeRequest::clear_ir_code_id() {
  _impl_.ir_code_id_.ClearToEmpty();
}
inline const std::string& ExecuteIRCodeRequest::ir_code_id() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeRequest.ir_code_id)
  return _internal_ir_code_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteIRCodeRequest::set_ir_code_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ir_code_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeRequest.ir_code_id)
}
inline std::string* ExecuteIRCodeRequest::mutable_ir_code_id() {
  std::string* _s = _internal_mutable_ir_code_id();
  // @@protoc_insertion_point(field_mutable:data.ExecuteIRCodeRequest.ir_code_id)
  return _s;
}
inline const std::string& ExecuteIRCodeRequest::_internal_ir_code_id() const {
  return _impl_.ir_code_id_.Get();
}
inline void ExecuteIRCodeRequest::_internal_set_ir_code_id(const std::string& value) {
  
  _impl_.ir_code_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeRequest::_internal_mutable_ir_code_id() {
  
  return _impl_.ir_code_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeRequest::release_ir_code_id() {
  // @@protoc_insertion_point(field_release:data.ExecuteIRCodeRequest.ir_code_id)
  return _impl_.ir_code_id_.Release();
}
inline void ExecuteIRCodeRequest::set_allocated_ir_code_id(std::string* ir_code_id) {
  if (ir_code_id != nullptr) {
    
  } else {
    
  }
  _impl_.ir_code_id_.SetAllocated(ir_code_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ir_code_id_.IsDefault()) {
    _impl_.ir_code_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ExecuteIRCodeRequest.ir_code_id)
}

// .data.ExecuteIRCodeRequest.ExecutionMode mode = 2;
inline void ExecuteIRCodeRequest::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::data::ExecuteIRCodeRequest_ExecutionMode ExecuteIRCodeRequest::_internal_mode() const {
  return static_cast< ::data::ExecuteIRCodeRequest_ExecutionMode >(_impl_.mode_);
}
inline ::data::ExecuteIRCodeRequest_ExecutionMode ExecuteIRCodeRequest::mode() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeRequest.mode)
  return _internal_mode();
}
inline void ExecuteIRCodeRequest::_internal_set_mode(::data::ExecuteIRCodeRequest_ExecutionMode value) {
  
  _impl_.mode_ = value;
}
inline void ExecuteIRCodeRequest::set_mode(::data::ExecuteIRCodeRequest_ExecutionMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeRequest.mode)
}

// map<string, string> parameters = 3;
inline int ExecuteIRCodeRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ExecuteIRCodeRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void ExecuteIRCodeRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExecuteIRCodeRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExecuteIRCodeRequest::parameters() const {
  // @@protoc_insertion_point(field_map:data.ExecuteIRCodeRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExecuteIRCodeRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExecuteIRCodeRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:data.ExecuteIRCodeRequest.parameters)
  return _internal_mutable_parameters();
}

// uint32 timeout = 4;
inline void ExecuteIRCodeRequest::clear_timeout() {
  _impl_.timeout_ = 0u;
}
inline uint32_t ExecuteIRCodeRequest::_internal_timeout() const {
  return _impl_.timeout_;
}
inline uint32_t ExecuteIRCodeRequest::timeout() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeRequest.timeout)
  return _internal_timeout();
}
inline void ExecuteIRCodeRequest::_internal_set_timeout(uint32_t value) {
  
  _impl_.timeout_ = value;
}
inline void ExecuteIRCodeRequest::set_timeout(uint32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeRequest.timeout)
}

// -------------------------------------------------------------------

// ExecuteIRCodeResponse

// bool success = 1;
inline void ExecuteIRCodeResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ExecuteIRCodeResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ExecuteIRCodeResponse::success() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeResponse.success)
  return _internal_success();
}
inline void ExecuteIRCodeResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ExecuteIRCodeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeResponse.success)
}

// string execution_result = 2;
inline void ExecuteIRCodeResponse::clear_execution_result() {
  _impl_.execution_result_.ClearToEmpty();
}
inline const std::string& ExecuteIRCodeResponse::execution_result() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeResponse.execution_result)
  return _internal_execution_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteIRCodeResponse::set_execution_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.execution_result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeResponse.execution_result)
}
inline std::string* ExecuteIRCodeResponse::mutable_execution_result() {
  std::string* _s = _internal_mutable_execution_result();
  // @@protoc_insertion_point(field_mutable:data.ExecuteIRCodeResponse.execution_result)
  return _s;
}
inline const std::string& ExecuteIRCodeResponse::_internal_execution_result() const {
  return _impl_.execution_result_.Get();
}
inline void ExecuteIRCodeResponse::_internal_set_execution_result(const std::string& value) {
  
  _impl_.execution_result_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeResponse::_internal_mutable_execution_result() {
  
  return _impl_.execution_result_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeResponse::release_execution_result() {
  // @@protoc_insertion_point(field_release:data.ExecuteIRCodeResponse.execution_result)
  return _impl_.execution_result_.Release();
}
inline void ExecuteIRCodeResponse::set_allocated_execution_result(std::string* execution_result) {
  if (execution_result != nullptr) {
    
  } else {
    
  }
  _impl_.execution_result_.SetAllocated(execution_result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.execution_result_.IsDefault()) {
    _impl_.execution_result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ExecuteIRCodeResponse.execution_result)
}

// string error_message = 3;
inline void ExecuteIRCodeResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ExecuteIRCodeResponse::error_message() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteIRCodeResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeResponse.error_message)
}
inline std::string* ExecuteIRCodeResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:data.ExecuteIRCodeResponse.error_message)
  return _s;
}
inline const std::string& ExecuteIRCodeResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ExecuteIRCodeResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:data.ExecuteIRCodeResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ExecuteIRCodeResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ExecuteIRCodeResponse.error_message)
}

// uint64 start_time = 4;
inline void ExecuteIRCodeResponse::clear_start_time() {
  _impl_.start_time_ = uint64_t{0u};
}
inline uint64_t ExecuteIRCodeResponse::_internal_start_time() const {
  return _impl_.start_time_;
}
inline uint64_t ExecuteIRCodeResponse::start_time() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeResponse.start_time)
  return _internal_start_time();
}
inline void ExecuteIRCodeResponse::_internal_set_start_time(uint64_t value) {
  
  _impl_.start_time_ = value;
}
inline void ExecuteIRCodeResponse::set_start_time(uint64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeResponse.start_time)
}

// uint64 end_time = 5;
inline void ExecuteIRCodeResponse::clear_end_time() {
  _impl_.end_time_ = uint64_t{0u};
}
inline uint64_t ExecuteIRCodeResponse::_internal_end_time() const {
  return _impl_.end_time_;
}
inline uint64_t ExecuteIRCodeResponse::end_time() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeResponse.end_time)
  return _internal_end_time();
}
inline void ExecuteIRCodeResponse::_internal_set_end_time(uint64_t value) {
  
  _impl_.end_time_ = value;
}
inline void ExecuteIRCodeResponse::set_end_time(uint64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeResponse.end_time)
}

// uint32 execution_duration = 6;
inline void ExecuteIRCodeResponse::clear_execution_duration() {
  _impl_.execution_duration_ = 0u;
}
inline uint32_t ExecuteIRCodeResponse::_internal_execution_duration() const {
  return _impl_.execution_duration_;
}
inline uint32_t ExecuteIRCodeResponse::execution_duration() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeResponse.execution_duration)
  return _internal_execution_duration();
}
inline void ExecuteIRCodeResponse::_internal_set_execution_duration(uint32_t value) {
  
  _impl_.execution_duration_ = value;
}
inline void ExecuteIRCodeResponse::set_execution_duration(uint32_t value) {
  _internal_set_execution_duration(value);
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeResponse.execution_duration)
}

// string execution_mode_used = 7;
inline void ExecuteIRCodeResponse::clear_execution_mode_used() {
  _impl_.execution_mode_used_.ClearToEmpty();
}
inline const std::string& ExecuteIRCodeResponse::execution_mode_used() const {
  // @@protoc_insertion_point(field_get:data.ExecuteIRCodeResponse.execution_mode_used)
  return _internal_execution_mode_used();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteIRCodeResponse::set_execution_mode_used(ArgT0&& arg0, ArgT... args) {
 
 _impl_.execution_mode_used_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:data.ExecuteIRCodeResponse.execution_mode_used)
}
inline std::string* ExecuteIRCodeResponse::mutable_execution_mode_used() {
  std::string* _s = _internal_mutable_execution_mode_used();
  // @@protoc_insertion_point(field_mutable:data.ExecuteIRCodeResponse.execution_mode_used)
  return _s;
}
inline const std::string& ExecuteIRCodeResponse::_internal_execution_mode_used() const {
  return _impl_.execution_mode_used_.Get();
}
inline void ExecuteIRCodeResponse::_internal_set_execution_mode_used(const std::string& value) {
  
  _impl_.execution_mode_used_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeResponse::_internal_mutable_execution_mode_used() {
  
  return _impl_.execution_mode_used_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteIRCodeResponse::release_execution_mode_used() {
  // @@protoc_insertion_point(field_release:data.ExecuteIRCodeResponse.execution_mode_used)
  return _impl_.execution_mode_used_.Release();
}
inline void ExecuteIRCodeResponse::set_allocated_execution_mode_used(std::string* execution_mode_used) {
  if (execution_mode_used != nullptr) {
    
  } else {
    
  }
  _impl_.execution_mode_used_.SetAllocated(execution_mode_used, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.execution_mode_used_.IsDefault()) {
    _impl_.execution_mode_used_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:data.ExecuteIRCodeResponse.execution_mode_used)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::data::Notification_NotifyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::Notification_NotifyType>() {
  return ::data::Notification_NotifyType_descriptor();
}
template <> struct is_proto_enum< ::data::ExecuteIRCodeRequest_ExecutionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::ExecuteIRCodeRequest_ExecutionMode>() {
  return ::data::ExecuteIRCodeRequest_ExecutionMode_descriptor();
}
template <> struct is_proto_enum< ::data::RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::RequestType>() {
  return ::data::RequestType_descriptor();
}
template <> struct is_proto_enum< ::data::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data::StatusCode>() {
  return ::data::StatusCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_data_5fproto_2eproto
